<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AlexaClientSDK: alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="avs-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AlexaClientSDK
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">A cross-platform, modular SDK for interacting with the Alexa Voice Service</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacealexa_client_s_d_k.html">alexaClientSDK</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common.html">avsCommon</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html">sds</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a></li><li class="navelem"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_buffer_layout_8h_source.html">BufferLayout.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html">Header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a847574951338367d9653fa881bf1567b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a847574951338367d9653fa881bf1567b">BufferLayout</a> (std::shared_ptr&lt; Buffer &gt; buffer)</td></tr>
<tr class="separator:a847574951338367d9653fa881bf1567b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141da3146e6aecf40fdfa1a3b7bf0511"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a141da3146e6aecf40fdfa1a3b7bf0511">~BufferLayout</a> ()</td></tr>
<tr class="memdesc:a141da3146e6aecf40fdfa1a3b7bf0511"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor ensures the <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a> is <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#acfac6a9f140154481592031a00376820">detach()</a>es</code> from the Buffer.  <a href="#a141da3146e6aecf40fdfa1a3b7bf0511">More...</a><br /></td></tr>
<tr class="separator:a141da3146e6aecf40fdfa1a3b7bf0511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508fb731e080cf4f00fe37b26a3bfea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html">Header</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a508fb731e080cf4f00fe37b26a3bfea7">getHeader</a> () const</td></tr>
<tr class="separator:a508fb731e080cf4f00fe37b26a3bfea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2b4c8d0e1577bb17d444b42e9c09e4"><td class="memItemLeft" align="right" valign="top">AtomicBool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a1f2b4c8d0e1577bb17d444b42e9c09e4">getReaderEnabledArray</a> () const</td></tr>
<tr class="separator:a1f2b4c8d0e1577bb17d444b42e9c09e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e57ffe050f3d48433ada613127b1d4"><td class="memItemLeft" align="right" valign="top">AtomicIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a58e57ffe050f3d48433ada613127b1d4">getReaderCursorArray</a> () const</td></tr>
<tr class="separator:a58e57ffe050f3d48433ada613127b1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525f244e35b9e62058ac1c51239f2e67"><td class="memItemLeft" align="right" valign="top">AtomicIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a525f244e35b9e62058ac1c51239f2e67">getReaderCloseIndexArray</a> () const</td></tr>
<tr class="separator:a525f244e35b9e62058ac1c51239f2e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bd2317a66fd86c8a51d6771b354b6a"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a00bd2317a66fd86c8a51d6771b354b6a">getDataSize</a> () const</td></tr>
<tr class="separator:a00bd2317a66fd86c8a51d6771b354b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84a47450de83faa54fcf2a0940fcb32"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#ac84a47450de83faa54fcf2a0940fcb32">getData</a> (Index at=0) const</td></tr>
<tr class="separator:ac84a47450de83faa54fcf2a0940fcb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fb025d842097831ddf836ba96c0dce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#ab1fb025d842097831ddf836ba96c0dce">init</a> (size_t wordSize, size_t maxReaders, size_t maxEphemeralReaders)</td></tr>
<tr class="separator:ab1fb025d842097831ddf836ba96c0dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0148da455e6b4e829d6822491c43d2b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a0148da455e6b4e829d6822491c43d2b9">attach</a> ()</td></tr>
<tr class="separator:a0148da455e6b4e829d6822491c43d2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfac6a9f140154481592031a00376820"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#acfac6a9f140154481592031a00376820">detach</a> ()</td></tr>
<tr class="separator:acfac6a9f140154481592031a00376820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4da95effc055498cb4651bf1109d1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#acf4da95effc055498cb4651bf1109d1e">isReaderEnabled</a> (size_t id) const</td></tr>
<tr class="separator:acf4da95effc055498cb4651bf1109d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aed7d16f55d3146b5314ae66b386147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a8aed7d16f55d3146b5314ae66b386147">enableReaderLocked</a> (size_t id)</td></tr>
<tr class="separator:a8aed7d16f55d3146b5314ae66b386147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49548d95ea6c4dea32cd790fb58ba682"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a49548d95ea6c4dea32cd790fb58ba682">disableReaderLocked</a> (size_t id)</td></tr>
<tr class="separator:a49548d95ea6c4dea32cd790fb58ba682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc17807c89077c147f9d444b28868d67"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#adc17807c89077c147f9d444b28868d67">wordsUntilWrap</a> (Index after) const</td></tr>
<tr class="separator:adc17807c89077c147f9d444b28868d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b86af1b66bd1a9c4738bbdc30ce0c11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a2b86af1b66bd1a9c4738bbdc30ce0c11">updateOldestUnconsumedCursor</a> ()</td></tr>
<tr class="memdesc:a2b86af1b66bd1a9c4738bbdc30ce0c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#aa01f090ac5c9489bc373e9f849e84a3b">updateOldestUnconsumedCursorLocked()</a></code> while holding <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html#adda067b2951365c319dbeade44a9c8bb">Header::backwardSeekMutex</a></code>.  <a href="#a2b86af1b66bd1a9c4738bbdc30ce0c11">More...</a><br /></td></tr>
<tr class="separator:a2b86af1b66bd1a9c4738bbdc30ce0c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01f090ac5c9489bc373e9f849e84a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#aa01f090ac5c9489bc373e9f849e84a3b">updateOldestUnconsumedCursorLocked</a> ()</td></tr>
<tr class="separator:aa01f090ac5c9489bc373e9f849e84a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a97f6639da74e007e3a396bfbcd3bdf17"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a97f6639da74e007e3a396bfbcd3bdf17">calculateDataOffset</a> (size_t wordSize, size_t maxReaders)</td></tr>
<tr class="separator:a97f6639da74e007e3a396bfbcd3bdf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0fae84a921b241ad86a9d72d5ce1602e"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a0fae84a921b241ad86a9d72d5ce1602e">MAGIC_NUMBER</a> = 0x53445348</td></tr>
<tr class="memdesc:a0fae84a921b241ad86a9d72d5ce1602e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic number used to identify a valid <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html">Header</a> in memory.  <a href="#a0fae84a921b241ad86a9d72d5ce1602e">More...</a><br /></td></tr>
<tr class="separator:a0fae84a921b241ad86a9d72d5ce1602e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe49b37ee31d2a956bb5783007addf0"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#affe49b37ee31d2a956bb5783007addf0">VERSION</a> = 2</td></tr>
<tr class="memdesc:affe49b37ee31d2a956bb5783007addf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of this header layout.  <a href="#affe49b37ee31d2a956bb5783007addf0">More...</a><br /></td></tr>
<tr class="separator:affe49b37ee31d2a956bb5783007addf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout&lt; T &gt;</h3>

<p>This is a nested class inside <code>SharedDatastream</code> which defines the layout of a <code>Buffer</code> for use with a <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a></code>. This layout begins with a fixed <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html">Header</a></code> structure, followed by two arrays of <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> <code>Indexes</code>, with the remainder allocated to data. All four of these sections are aligned on a 64-bit boundary. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a847574951338367d9653fa881bf1567b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847574951338367d9653fa881bf1567b">&#9670;&nbsp;</a></span>BufferLayout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; Buffer &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The constructor only initializes a shared pointer to the provided buffer. Attaching and/or initializing is performed by the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#ab1fb025d842097831ddf836ba96c0dce">init()</a>/<code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a0148da455e6b4e829d6822491c43d2b9">attach()</a></code> functions</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The raw buffer which holds (or will hold) the header, arrays, and circular data buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a141da3146e6aecf40fdfa1a3b7bf0511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141da3146e6aecf40fdfa1a3b7bf0511">&#9670;&nbsp;</a></span>~BufferLayout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::~<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The destructor ensures the <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a> is <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#acfac6a9f140154481592031a00376820">detach()</a>es</code> from the Buffer. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0148da455e6b4e829d6822491c43d2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0148da455e6b4e829d6822491c43d2b9">&#9670;&nbsp;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::attach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function tries to attach this <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></code> to a <code>Buffer</code> which was already initialized by another <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></code>. This function will verify that the <code>Buffer</code> contains a valid header which is compatible with this <code>Buffer's</code> traits. This function can be safely called from multiple threads or processes after another another <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></code> which is managing the same <code>Buffer</code> has completed a call to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#ab1fb025d842097831ddf836ba96c0dce">init()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successfully attached (<code>Buffer</code> contains a valid and compatible header), else <code>false</code>. </dd></dl>

</div>
</div>
<a id="a97f6639da74e007e3a396bfbcd3bdf17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f6639da74e007e3a396bfbcd3bdf17">&#9670;&nbsp;</a></span>calculateDataOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::calculateDataOffset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wordSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxReaders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function calculates the offset (in bytes) from the start of a <code>Buffer</code> to the start of the circular data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wordSize</td><td>The size (in bytes) of words in the stream. All <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a></code> operations that work with data or position in the stream are quantified in words. </td></tr>
    <tr><td class="paramname">maxReaders</td><td>The maximum number of readers the stream will support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset (in bytes) from the start of a <code>Buffer</code> to the start of the circular data. </dd></dl>

</div>
</div>
<a id="acfac6a9f140154481592031a00376820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfac6a9f140154481592031a00376820">&#9670;&nbsp;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function detaches from the <code>Buffer</code> which it is managing. If this is the last <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></code> attached to the <code>Buffer</code>, it will also call the destructors on the objects in the <code>Buffer</code>. </p>

</div>
</div>
<a id="a49548d95ea6c4dea32cd790fb58ba682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49548d95ea6c4dea32cd790fb58ba682">&#9670;&nbsp;</a></span>disableReaderLocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::disableReaderLocked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function disables the specified reader. The caller must be holding <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html#a27abd67dbb60a2e42696abed67ad32e4">Header::readerEnableMutex</a> when calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the reader to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aed7d16f55d3146b5314ae66b386147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aed7d16f55d3146b5314ae66b386147">&#9670;&nbsp;</a></span>enableReaderLocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::enableReaderLocked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function enables the specified reader. The caller must be holding <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html#a27abd67dbb60a2e42696abed67ad32e4">Header::readerEnableMutex</a> when calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the reader to enable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac84a47450de83faa54fcf2a0940fcb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84a47450de83faa54fcf2a0940fcb32">&#9670;&nbsp;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::getData </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>at</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides access to the data (non-Header) portion of <code>buffer</code>.</p>
<p>The data comes next in <code>m_buffer</code> after the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a525f244e35b9e62058ac1c51239f2e67">getReaderCloseIndexArray()</a></code> array listed above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">at</td><td>An optional word <code>Index</code> to get a data pointer for. This function will calculate where <code>at</code> would fall in the circular buffer and return a pointer to it, but note that this function does not check whether the specified <code>Index</code> currently resides in the buffer. This parameter defaults to 0, which will return a pointer to the base of the circular data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the data which would hold the specified <code>Index</code>. </dd></dl>

</div>
</div>
<a id="a00bd2317a66fd86c8a51d6771b354b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bd2317a66fd86c8a51d6771b354b6a">&#9670;&nbsp;</a></span>getDataSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SharedDataStream&lt; T &gt;::Index <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::getDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the size (in words) of the data (non-Header) portion of <code>buffer</code>. The data comes next in <code>m_buffer</code> after the <code>getReaderCloseIndexarray()</code> listed above.</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of words the stream can store. </dd></dl>

</div>
</div>
<a id="a508fb731e080cf4f00fe37b26a3bfea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508fb731e080cf4f00fe37b26a3bfea7">&#9670;&nbsp;</a></span>getHeader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SharedDataStream&lt; T &gt;::<a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html">BufferLayout::Header</a> * <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::getHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides access to the <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html">Header</a> structure stored at the start of the <code>Buffer</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html">Header</a></code> structure inside the <code>Buffer</code>. </dd></dl>

</div>
</div>
<a id="a525f244e35b9e62058ac1c51239f2e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525f244e35b9e62058ac1c51239f2e67">&#9670;&nbsp;</a></span>getReaderCloseIndexArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SharedDataStream&lt; T &gt;::AtomicIndex * <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::getReaderCloseIndexArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides access to the array of indices which specify the <code>Index</code> where each <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> will stop reading. When a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a>'s</code> close <code>Index</code> is set to zero, this indicates that the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> is disabled. When a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a>'s</code> close <code>Index</code> is less than or equal to the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a>'s</code> cursor, this indicates that the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> has reached the end of its stream, and subsequent calls to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#af003c65c65026bbbbd27101f2094cb8c">Reader::read()</a></code> will return 0. When a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a>'s</code> close <code>Index</code> is greater than the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a>'s</code> cursor, the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> will continue to return data as it becomes available in the stream up to the point when it reaches the close <code>Index</code>.</p>
<dl class="section note"><dt>Note</dt><dd>An enabled <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> will initially have its close <code>Index</code> set to <code>std::numeric_limits_max&lt;AtomicIndex&gt;</code>, meaning it can effectively continue to read indefinitely, until the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_writer.html">Writer</a></code> closes. If a call to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a0bfaf0f8a72a0d7bd2be54fe1068708d">Reader::close()</a></code> occurs, it will move the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a>'s</code> close <code>Index</code> to the current write start cursor, which will cause the read stream to end when the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> finishes consuming the data that was in the buffer at the time <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a0bfaf0f8a72a0d7bd2be54fe1068708d">Reader::close()</a></code> was called.</dd></dl>
<p>This array of close <code>Index</code> indices comes next in <code>m_buffer</code> after the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a58e57ffe050f3d48433ada613127b1d4">getReaderCursorArray()</a></code> listed above.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the array of <code>maxReaders</code> close <code>Indexes</code>. </dd></dl>

</div>
</div>
<a id="a58e57ffe050f3d48433ada613127b1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e57ffe050f3d48433ada613127b1d4">&#9670;&nbsp;</a></span>getReaderCursorArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SharedDataStream&lt; T &gt;::AtomicIndex * <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::getReaderCursorArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides access to the array of indices which specify the location each <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> will read from.</p>
<p>This array of cursor indices comes next in <code>m_buffer</code> after the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a1f2b4c8d0e1577bb17d444b42e9c09e4">getReaderEnabledArray()</a></code> listed above.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the array of <code>maxReaders</code> cursor <code>Indexes</code>. </dd></dl>

</div>
</div>
<a id="a1f2b4c8d0e1577bb17d444b42e9c09e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2b4c8d0e1577bb17d444b42e9c09e4">&#9670;&nbsp;</a></span>getReaderEnabledArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SharedDataStream&lt; T &gt;::AtomicBool * <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::getReaderEnabledArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides access to the array of booleans which specify whether a particular reader is enabled.</p>
<p>This array of enabled booleans comes next in <code>m_buffer</code> after the <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html">Header</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the array of <code>maxReaders</code> cursor <code>Indexes</code>. </dd></dl>

</div>
</div>
<a id="ab1fb025d842097831ddf836ba96c0dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1fb025d842097831ddf836ba96c0dce">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wordSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxReaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxEphemeralReaders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initalizes the <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html">Header</a></code> and arrays in the <code>Buffer</code> managed by this <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></code>. This function must not be called on a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></code> which is managing a <code>Buffer</code> which has already been initialized. This function must return before attempting to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#a0148da455e6b4e829d6822491c43d2b9">attach()</a></code> another <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></code> to the <code>Buffer</code> being initialized here. This function must not be called if the <code>Buffer</code> it would initialized has other <code>BufferLayouts</code> attached to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wordSize</td><td>The size (in bytes) of words in the stream. All <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a></code> operations that work with data or position in the stream are quantified in words. </td></tr>
    <tr><td class="paramname">maxReaders</td><td>The maximum number of readers the stream will support. </td></tr>
    <tr><td class="paramname">maxEphemeralReaders</td><td>The maximum number of readers that can be created without specifying a reader id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if wordSize or maxReaders are too large to be stored, else <code>true</code>. </dd></dl>

</div>
</div>
<a id="acf4da95effc055498cb4651bf1109d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4da95effc055498cb4651bf1109d1e">&#9670;&nbsp;</a></span>isReaderEnabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::isReaderEnabled </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks whether the specified reader is enabled.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not require the caller to hold <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html#a27abd67dbb60a2e42696abed67ad32e4">Header::readerEnableMutex</a>. Reading the enabled flag is an atomic operation in and of itself. It is up to the caller to determine whether there are subsequent operations which depend on the enabled state that might require holding the mutex to avoid a race condition.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the reader to check the enabled status of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified reader is enabled, else <code>false</code>. </dd></dl>

</div>
</div>
<a id="a2b86af1b66bd1a9c4738bbdc30ce0c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b86af1b66bd1a9c4738bbdc30ce0c11">&#9670;&nbsp;</a></span>updateOldestUnconsumedCursor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::updateOldestUnconsumedCursor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html#aa01f090ac5c9489bc373e9f849e84a3b">updateOldestUnconsumedCursorLocked()</a></code> while holding <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html#adda067b2951365c319dbeade44a9c8bb">Header::backwardSeekMutex</a></code>. </p>

</div>
</div>
<a id="aa01f090ac5c9489bc373e9f849e84a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01f090ac5c9489bc373e9f849e84a3b">&#9670;&nbsp;</a></span>updateOldestUnconsumedCursorLocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::updateOldestUnconsumedCursorLocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function scans through the array of <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> cursors, finds the oldest enabled cursor, and records it in <code>oldestUnconsumedCursor</code>. This function should be called whenever a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> moves its cursor. This function needs to guarantee that no <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> cursors are older than <code>oldestUnconsumedCursor</code> when it completes, so it holds <code>backwardSeekMutex</code> to prevent race conditions. This function must be called while holding <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html#adda067b2951365c319dbeade44a9c8bb">Header::backwardSeekMutex</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Without mutexes, any <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#af003c65c65026bbbbd27101f2094cb8c">Reader::read()</a></code> or <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a4fff66cc486dd687247c6414540f978b">Reader::seek()</a></code> call could move a read cursor while this function is iterating through the list of <code>Readers</code>. The <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#af003c65c65026bbbbd27101f2094cb8c">Reader::read()</a></code> calls will always move their cursors to a newer location, so no mutex is needed (if this function looks at a particular <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> and updates <code>oldestUnconsumedCursor</code>, and the <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a> later <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#af003c65c65026bbbbd27101f2094cb8c">Reader::read()</a>s</code> before this function finishes, <code>oldestUnconsumedCursor</code> will still be older than that <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code>, so there is no problem). Similarly, <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a4fff66cc486dd687247c6414540f978b">Reader::seek()</a></code> calls which move the cursor to a newer location are not a problem, but <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a4fff66cc486dd687247c6414540f978b">Reader::seek()</a></code> calls which move a cursor backwards pose a risk of a race condition. If this function looks at a particular <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code>, and the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> does a backwards <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a4fff66cc486dd687247c6414540f978b">Reader::seek()</a></code> after it has been examined, this function could end up with <code>oldestUnconsumedCursor</code> at an <code>Index</code> which is ahead of the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> that performed the backwards <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a4fff66cc486dd687247c6414540f978b">Reader::seek()</a></code>. To prevent this race condition, this function takes the <code>backwardSeekMutex</code>, which prevents backwards <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a4fff66cc486dd687247c6414540f978b">Reader::seek()</a>s</code> while <code>oldestUnconsumedCursor</code> is being updated.</dd>
<dd>
As an optimization, we could skip this function if <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_writer.html">Writer</a> policy is nonblockable (ACSDK-251). </dd></dl>

</div>
</div>
<a id="adc17807c89077c147f9d444b28868d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc17807c89077c147f9d444b28868d67">&#9670;&nbsp;</a></span>wordsUntilWrap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SharedDataStream&lt; T &gt;::Index <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::wordsUntilWrap </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>after</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a count of the number of words after the specified <code>Index</code> before the circular data will wrap.</p>
<p><code>param</code> after The <code>Index</code> to count from. <code>return</code> The count of words after <code>after</code> until the circular data will wrap. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0fae84a921b241ad86a9d72d5ce1602e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fae84a921b241ad86a9d72d5ce1602e">&#9670;&nbsp;</a></span>MAGIC_NUMBER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::MAGIC_NUMBER = 0x53445348</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Magic number used to identify a valid <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout_1_1_header.html">Header</a> in memory. </p>

</div>
</div>
<a id="affe49b37ee31d2a956bb5783007addf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe49b37ee31d2a956bb5783007addf0">&#9670;&nbsp;</a></span>VERSION</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::BufferLayout</a>&lt; T &gt;::VERSION = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of this header layout. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/workplace/avs-device-sdk/AVSCommon/Utils/include/AVSCommon/Utils/SDS/<a class="el" href="_buffer_layout_8h_source.html">BufferLayout.h</a></li>
</ul>
</div><!-- contents -->
<html>
  <body>
    <p style="text-align:left;">
      AlexaClientSDK 3.0.0 - Copyright 2016-2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
      <span style="float:right;">
	Licensed under the <a HREF=http://aws.amazon.com/apache2.0/>Apache License, Version 2.0</a>
      </span>
    </p>
  </body>
</html>
