<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AlexaClientSDK: alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="avs-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AlexaClientSDK
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">A cross-platform, modular SDK for interacting with the Alexa Voice Service</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacealexa_client_s_d_k.html">alexaClientSDK</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common.html">avsCommon</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html">mediaPlayer</a></li><li class="navelem"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html">MediaPlayerInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_media_player_interface_8h_source.html">MediaPlayerInterface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface__inherit__graph.png" border="0" usemap="#alexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface_inherit__map" alt="Inheritance graph"/></div>
<map name="alexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface_inherit__map" id="alexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface_inherit__map">
<area shape="rect" id="node2" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1test_1_1_mock_media_player_helper.html" title="alexaClientSDK::avsCommon\l::utils::mediaPlayer::test\l::MockMediaPlayerHelper" alt="" coords="285,5,482,61"/>
<area shape="rect" id="node5" href="classalexa_client_s_d_k_1_1media_player_1_1android_1_1_android_s_l_e_s_media_player.html" title="alexaClientSDK::mediaPlayer\l::android::AndroidSLESMediaPlayer" alt="" coords="268,86,499,127"/>
<area shape="rect" id="node6" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html" title="alexaClientSDK::mediaPlayer\l::MediaPlayer" alt="" coords="286,151,481,193"/>
<area shape="rect" id="node3" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1test_1_1_mock_media_player.html" title="A mock MediaPlayer for unit tests. " alt="" coords="547,5,744,61"/>
<area shape="rect" id="node4" href="classalexa_client_s_d_k_1_1acsdk_alerts_1_1renderer_1_1test_1_1_test_media_player.html" title="alexaClientSDK::acsdkAlerts\l::renderer::test::TestMediaPlayer" alt="" coords="792,13,1005,54"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a97b83ae4aaeabff7bb8a796a8a018623"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> = uint64_t</td></tr>
<tr class="memdesc:a97b83ae4aaeabff7bb8a796a8a018623"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that identifies which source is currently being operated on. This must be unique across all instances.  <a href="#a97b83ae4aaeabff7bb8a796a8a018623">More...</a><br /></td></tr>
<tr class="separator:a97b83ae4aaeabff7bb8a796a8a018623"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ea8410b0e942e263e7b534f88b30ee3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a6ea8410b0e942e263e7b534f88b30ee3">~MediaPlayerInterface</a> ()=default</td></tr>
<tr class="separator:a6ea8410b0e942e263e7b534f88b30ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d4939aca91bef956234f7ceaf35a7d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource</a> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">avsCommon::avs::attachment::AttachmentReader</a> &gt; attachmentReader, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_audio_format.html">avsCommon::utils::AudioFormat</a> *format=nullptr, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_source_config.html">SourceConfig</a> &amp;config=<a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html#a93b9bf962eedc9791f4bc1560e93e8e5">emptySourceConfig</a>())=0</td></tr>
<tr class="separator:ad3d4939aca91bef956234f7ceaf35a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df17fc30e2ee59053cdaef64b021fe2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a5df17fc30e2ee59053cdaef64b021fe2">setSource</a> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">avsCommon::avs::attachment::AttachmentReader</a> &gt; attachmentReader, std::chrono::milliseconds offsetAdjustment, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_audio_format.html">avsCommon::utils::AudioFormat</a> *format=nullptr, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_source_config.html">SourceConfig</a> &amp;config=<a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html#a93b9bf962eedc9791f4bc1560e93e8e5">emptySourceConfig</a>())=0</td></tr>
<tr class="separator:a5df17fc30e2ee59053cdaef64b021fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baee600aab3cae55ea051cf411624f4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a5baee600aab3cae55ea051cf411624f4">setSource</a> (const std::string &amp;url, std::chrono::milliseconds offset=std::chrono::milliseconds::zero(), const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_source_config.html">SourceConfig</a> &amp;config=<a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html#a93b9bf962eedc9791f4bc1560e93e8e5">emptySourceConfig</a>(), bool repeat=false, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_playback_context.html">PlaybackContext</a> &amp;playbackContext=<a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_playback_context.html">PlaybackContext</a>())=0</td></tr>
<tr class="separator:a5baee600aab3cae55ea051cf411624f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56654e0dc59b964a23b83ca9ef74d37"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ab56654e0dc59b964a23b83ca9ef74d37">setSource</a> (std::shared_ptr&lt; std::istream &gt; stream, bool repeat=false, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_source_config.html">SourceConfig</a> &amp;config=<a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html#a93b9bf962eedc9791f4bc1560e93e8e5">emptySourceConfig</a>(), <a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils.html#a23c4c0b3872cf0413515899644d25924">avsCommon::utils::MediaType</a> format=<a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils.html#a23c4c0b3872cf0413515899644d25924a696b031073e74bf2cb98e5ef201d4aa3">avsCommon::utils::MediaType::UNKNOWN</a>)=0</td></tr>
<tr class="separator:ab56654e0dc59b964a23b83ca9ef74d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd648268d8afaf23312dad7e21238ad"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> id)=0</td></tr>
<tr class="separator:a2bd648268d8afaf23312dad7e21238ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422503c5051d68fdab1485b74c0c33a1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a422503c5051d68fdab1485b74c0c33a1">stop</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> id)=0</td></tr>
<tr class="separator:a422503c5051d68fdab1485b74c0c33a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfc7029b2be6e2c756bf09dcf94de22"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a6bfc7029b2be6e2c756bf09dcf94de22">stop</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> id, std::chrono::seconds timeToPipelineShutdown)</td></tr>
<tr class="separator:a6bfc7029b2be6e2c756bf09dcf94de22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7352a3ad1c63e92bf19455f3abdd0e76"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a7352a3ad1c63e92bf19455f3abdd0e76">pause</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> id)=0</td></tr>
<tr class="separator:a7352a3ad1c63e92bf19455f3abdd0e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bddbef99754845f428924d7b8883eb8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a1bddbef99754845f428924d7b8883eb8">resume</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> id)=0</td></tr>
<tr class="separator:a1bddbef99754845f428924d7b8883eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc2c8df7870510380a2a3e3946b72d8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2cc2c8df7870510380a2a3e3946b72d8">seekTo</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> id, std::chrono::milliseconds location, bool fromStart)</td></tr>
<tr class="separator:a2cc2c8df7870510380a2a3e3946b72d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1e46a268eebc25fb35f733752f3a72"><td class="memItemLeft" align="right" valign="top">virtual std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a9f1e46a268eebc25fb35f733752f3a72">getOffset</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> id)=0</td></tr>
<tr class="separator:a9f1e46a268eebc25fb35f733752f3a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f356052a19748eb924ee39059dccf1"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a77f356052a19748eb924ee39059dccf1">getNumBytesBuffered</a> ()=0</td></tr>
<tr class="separator:a77f356052a19748eb924ee39059dccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561392afa0c0e17a45c6d8b2f41b219e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_optional.html">utils::Optional</a>&lt; <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">avsCommon::utils::mediaPlayer::MediaPlayerState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a561392afa0c0e17a45c6d8b2f41b219e">getMediaPlayerState</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> id)=0</td></tr>
<tr class="separator:a561392afa0c0e17a45c6d8b2f41b219e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a16150dc5c414ba33a6f20dd7547d52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2a16150dc5c414ba33a6f20dd7547d52">addObserver</a> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html">avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a> &gt; playerObserver)=0</td></tr>
<tr class="separator:a2a16150dc5c414ba33a6f20dd7547d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370fcb089b7026f6ad91001bf4ace1d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a370fcb089b7026f6ad91001bf4ace1d0">removeObserver</a> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html">avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a> &gt; playerObserver)=0</td></tr>
<tr class="separator:a370fcb089b7026f6ad91001bf4ace1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a6152987ceb8b18d48b14e080d1169"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_optional.html">utils::Optional</a>&lt; <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_playback_attributes.html">PlaybackAttributes</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#aa5a6152987ceb8b18d48b14e080d1169">getPlaybackAttributes</a> ()</td></tr>
<tr class="separator:aa5a6152987ceb8b18d48b14e080d1169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae032b13a1184c2394de42e4fffa6f093"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_playback_report.html">PlaybackReport</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ae032b13a1184c2394de42e4fffa6f093">getPlaybackReports</a> ()</td></tr>
<tr class="separator:ae032b13a1184c2394de42e4fffa6f093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6427e9fec805730db5264370c47cdcd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_optional.html">utils::Optional</a>&lt; <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_fingerprint.html">Fingerprint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ae6427e9fec805730db5264370c47cdcd">getFingerprint</a> ()</td></tr>
<tr class="separator:ae6427e9fec805730db5264370c47cdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a94e049f4cbbd174ef8e6c15387dd85ea"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a94e049f4cbbd174ef8e6c15387dd85ea">ERROR</a> = 0</td></tr>
<tr class="memdesc:a94e049f4cbbd174ef8e6c15387dd85ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code>SourceId</code> used to represent an error from calls to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code>.  <a href="#a94e049f4cbbd174ef8e6c15387dd85ea">More...</a><br /></td></tr>
<tr class="separator:a94e049f4cbbd174ef8e6c15387dd85ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html">MediaPlayerInterface</a></code> allows for sourcing, playback control, navigation, and querying the state of media content. A <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html">MediaPlayerInterface</a></code> implementation must only handle one source at a time.</p>
<p>Each playback controlling API call (i.e. <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a></code>, <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a7352a3ad1c63e92bf19455f3abdd0e76">pause()</a></code>, <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a422503c5051d68fdab1485b74c0c33a1">stop()</a></code>, <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a1bddbef99754845f428924d7b8883eb8">resume()</a></code>) that succeeds will also result in a callback to the observer. To see how to tell when a method succeeded, please refer to the documentation of each method.</p>
<p>An implementation can call <code>onPlaybackError()</code> at any time. If an <code>onPlaybackError()</code> callback occurs while a plaback controlling API call is waiting for a callback, the original callback must not be made, and the implementation should revert to a stopped state. Any subsequent operations after an <code>onPlaybackError()</code> callback must be preceded by a new <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code> call.</p>
<p>Implementations must make a call to <code>onPlaybackStopped()</code> with the previous <code>SourceId</code> when a new source is set if the previous source was in a non-stopped state.</p>
<p><code>note</code> A <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html">MediaPlayerInterface</a></code> implementation must be able to support the various audio formats listed at: <a href="https://developer.amazon.com/docs/alexa/alexa-voice-service/recommended-media-support.html">https://developer.amazon.com/docs/alexa/alexa-voice-service/recommended-media-support.html</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a97b83ae4aaeabff7bb8a796a8a018623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b83ae4aaeabff7bb8a796a8a018623">&#9670;&nbsp;</a></span>SourceId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId</a> =  uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type that identifies which source is currently being operated on. This must be unique across all instances. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6ea8410b0e942e263e7b534f88b30ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea8410b0e942e263e7b534f88b30ee3">&#9670;&nbsp;</a></span>~MediaPlayerInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::~MediaPlayerInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2a16150dc5c414ba33a6f20dd7547d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a16150dc5c414ba33a6f20dd7547d52">&#9670;&nbsp;</a></span>addObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::addObserver </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html">avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>playerObserver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds an observer to be notified when playback state changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">playerObserver</td><td>The observer to send the notifications to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6427e9fec805730db5264370c47cdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6427e9fec805730db5264370c47cdcd">&#9670;&nbsp;</a></span>getFingerprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_optional.html">utils::Optional</a>&lt; <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_fingerprint.html">Fingerprint</a> &gt; alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::getFingerprint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get fingerprint</p>
<dl class="section return"><dt>Returns</dt><dd>Media Player fingerprint </dd></dl>

</div>
</div>
<a id="a561392afa0c0e17a45c6d8b2f41b219e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561392afa0c0e17a45c6d8b2f41b219e">&#9670;&nbsp;</a></span>getMediaPlayerState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_optional.html">utils::Optional</a>&lt;<a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">avsCommon::utils::mediaPlayer::MediaPlayerState</a>&gt; alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::getMediaPlayerState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current state of the media player source, including the id and offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique id of the source for the desired state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_optional.html">Optional</a> state including the offset. A blank <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_optional.html">Optional</a> is returned if retrieving this information fails. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a0a96ad94a4f159c44852a2534e65d900">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1android_1_1_android_s_l_e_s_media_player.html#a424286c9b921cd8b8893eace2d6baad2">alexaClientSDK::mediaPlayer::android::AndroidSLESMediaPlayer</a>.</p>

</div>
</div>
<a id="a77f356052a19748eb924ee39059dccf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f356052a19748eb924ee39059dccf1">&#9670;&nbsp;</a></span>getNumBytesBuffered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::getNumBytesBuffered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of bytes queued up in the media player buffers.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes currently queued in this MediaPlayer's buffer. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#afad3bdc0d72ad4e80b6fb9d48c668a3b">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1android_1_1_android_s_l_e_s_media_player.html#a874fb5e4e4e70c908de9cbb0ab0ef55b">alexaClientSDK::mediaPlayer::android::AndroidSLESMediaPlayer</a>.</p>

</div>
</div>
<a id="a9f1e46a268eebc25fb35f733752f3a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1e46a268eebc25fb35f733752f3a72">&#9670;&nbsp;</a></span>getOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::chrono::milliseconds alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::getOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the offset, in milliseconds, of the media source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique id of the source on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the specified source is playing, the offset in milliseconds that the source has been playing will be returned. If the specified source is not playing, the last offset it played will be returned.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use <code>getMediaPlayerState</code> instead, which contains the offset </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ae9b262d5eae687beaa30d9dc7e28d4e8">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1android_1_1_android_s_l_e_s_media_player.html#a1880a09b2dd2558113a9aab4da287de1">alexaClientSDK::mediaPlayer::android::AndroidSLESMediaPlayer</a>.</p>

</div>
</div>
<a id="aa5a6152987ceb8b18d48b14e080d1169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a6152987ceb8b18d48b14e080d1169">&#9670;&nbsp;</a></span>getPlaybackAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_optional.html">utils::Optional</a>&lt; <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_playback_attributes.html">PlaybackAttributes</a> &gt; alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::getPlaybackAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_playback_attributes.html">PlaybackAttributes</a></code> for the current stream being played. This method only needs to be implemented if your mediaplayer supports Premium Audio.</p>
<dl class="section return"><dt>Returns</dt><dd>playbackAttributes The playback attributes for the current stream if premium audio is supported and it has an active source; otherwise, an empty object. </dd></dl>

</div>
</div>
<a id="ae032b13a1184c2394de42e4fffa6f093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae032b13a1184c2394de42e4fffa6f093">&#9670;&nbsp;</a></span>getPlaybackReports()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_playback_report.html">PlaybackReport</a> &gt; alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::getPlaybackReports </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get list of <code>PlaybackReports</code> for current track. This method only needs to be implemented if your mediaplayer supports Premium Audio.</p>
<dl class="section return"><dt>Returns</dt><dd>The list of <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_playback_report.html">PlaybackReport</a></code> for current track if premium audio is supported and it has an active source; otherwise, an empty list. </dd></dl>

</div>
</div>
<a id="a7352a3ad1c63e92bf19455f3abdd0e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7352a3ad1c63e92bf19455f3abdd0e76">&#9670;&nbsp;</a></span>pause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::pause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pauses playing audio specified by the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code> call.</p>
<p>The source must be set before issuing <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a7352a3ad1c63e92bf19455f3abdd0e76">pause()</a></code>. If <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a7352a3ad1c63e92bf19455f3abdd0e76">pause()</a></code> is called </p><ul>
<li>without making a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code>, <code>false</code> will be returned. </li>
<li>when audio is not starting/resuming/playing, <code>false</code> will be returned. </li>
<li>when a <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a> or <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a1bddbef99754845f428924d7b8883eb8">resume()</a> call has already been made, but no callback has been issued yet for those functions, the audio stream will pause without playing any audio. Implementations must call both <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a423d815f2188441452e0cd8ea955ae87">MediaPlayerObserverInterface::onPlaybackStarted()</a></code> / <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a13efb5dc6fb13418ba67221b2c9ea936">MediaPlayerObserverInterface::onPlaybackResumed</a></code> and <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#af20f86b9956188ce46efbc59dc2e648d">MediaPlayerObserverInterface::onPlaybackPaused()</a></code> in this scenario, as both the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a></code> / <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a1bddbef99754845f428924d7b8883eb8">resume()</a></code> and the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a7352a3ad1c63e92bf19455f3abdd0e76">pause()</a></code> are required to have corresponding callbacks.</li>
</ul>
<p>If the id does not match the id of the active source, then <code>false</code> will be returned. If the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a7352a3ad1c63e92bf19455f3abdd0e76">pause()</a></code> succeeded, <code>true</code> will be returned. When <code>true</code> is returned, a callback will be made to either <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#af20f86b9956188ce46efbc59dc2e648d">MediaPlayerObserverInterface::onPlaybackPaused()</a></code> or to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a9c42c6f619e28e888c56a51edcccd07c">MediaPlayerObserverInterface::onPlaybackError()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique id of the source on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the call succeeded, in which case a callback will be made, or <code>false</code> otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#aeeb3334b462899a3bab9bb41e9f2f69e">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1android_1_1_android_s_l_e_s_media_player.html#aaa23e4dd4692f0cc3a4ad481435af078">alexaClientSDK::mediaPlayer::android::AndroidSLESMediaPlayer</a>.</p>

</div>
</div>
<a id="a2bd648268d8afaf23312dad7e21238ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd648268d8afaf23312dad7e21238ad">&#9670;&nbsp;</a></span>play()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::play </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts playing audio specified by the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code> call.</p>
<p>The source must be set before issuing <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a></code>.</p>
<p>If <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a></code> is called </p><ul>
<li>without making a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code>, <code>false</code> will be returned. </li>
<li>when audio is already playing, <code>false</code> will be returned. </li>
<li>after a <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a> call has already been made but no callback or return code has been issued yet, <code>false</code> will be returned.</li>
</ul>
<p>If the id does not match the id of the active source, then <code>false</code> will be returned. If the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a></code> succeeded, <code>true</code> will be returned. When <code>true</code> is returned, a callback will be made to either <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a423d815f2188441452e0cd8ea955ae87">MediaPlayerObserverInterface::onPlaybackStarted()</a></code> or to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a9c42c6f619e28e888c56a51edcccd07c">MediaPlayerObserverInterface::onPlaybackError()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique id of the source on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the call succeeded, in which case a callback will be made, or <code>false</code> otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a6e3f97c24a5ee8cf5ad698de4ff70362">alexaClientSDK::mediaPlayer::MediaPlayer</a>, <a class="el" href="classalexa_client_s_d_k_1_1acsdk_alerts_1_1renderer_1_1test_1_1_test_media_player.html#a765bba016a9e4b135e30b8b2a1644386">alexaClientSDK::acsdkAlerts::renderer::test::TestMediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1android_1_1_android_s_l_e_s_media_player.html#a36eb643712a0bb96acdd43632e4d3a88">alexaClientSDK::mediaPlayer::android::AndroidSLESMediaPlayer</a>.</p>

</div>
</div>
<a id="a370fcb089b7026f6ad91001bf4ace1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370fcb089b7026f6ad91001bf4ace1d0">&#9670;&nbsp;</a></span>removeObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::removeObserver </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html">avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>playerObserver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes an observer to be notified when playback state changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">playerObserver</td><td>The observer to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bddbef99754845f428924d7b8883eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bddbef99754845f428924d7b8883eb8">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resumes playing the paused audio specified by the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code> call.</p>
<p>The source must be set before issuing <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a1bddbef99754845f428924d7b8883eb8">resume()</a></code>. If <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a1bddbef99754845f428924d7b8883eb8">resume()</a></code> is called </p><ul>
<li>without making a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code>, <code>false</code> will be returned. </li>
<li>when audio is already playing, <code>false</code> will be returned. </li>
<li>when audio is not paused, <code>false</code> will be returned. </li>
<li>after a <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a1bddbef99754845f428924d7b8883eb8">resume()</a> call has already been made but no callback or return code has been issued yet, <code>false</code> will be returned.</li>
</ul>
<p>If the id does not match the id of the active source, then <code>false</code> will be returned. If the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a1bddbef99754845f428924d7b8883eb8">resume()</a></code> succeeded, <code>true</code> will be returned. When <code>true</code> is returned, a callback will be made to either <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a13efb5dc6fb13418ba67221b2c9ea936">MediaPlayerObserverInterface::onPlaybackResumed()</a></code> or to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a9c42c6f619e28e888c56a51edcccd07c">MediaPlayerObserverInterface::onPlaybackError()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique id of the source on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the call succeeded, in which case a callback will be made, or <code>false</code> otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#afd6e7598a71b9a91409fc683b7886e9b">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1android_1_1_android_s_l_e_s_media_player.html#af9da612c856654050524399ae75765d5">alexaClientSDK::mediaPlayer::android::AndroidSLESMediaPlayer</a>.</p>

</div>
</div>
<a id="a2cc2c8df7870510380a2a3e3946b72d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc2c8df7870510380a2a3e3946b72d8">&#9670;&nbsp;</a></span>seekTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::seekTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Seek to a position within the current song. This should only be called after setSource, and while playing or after a call to <code>stop(id, timeout)</code> before the timeout period has expired. NOTE: A call to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2cc2c8df7870510380a2a3e3946b72d8">seekTo()</a></code> while STOPPED will not result in playback starting. If the pipeline has shutdown, false will be returned, if the pipeline is still open, a <code>onSeeked</code> callback will be made with the requested location as the endState offset, but playback will not resume until <code>play</code> is called again.</p>
<p>NOTE: Default empty implementation to avoid build breakage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique id of the source on which to operate. </td></tr>
    <tr><td class="paramname">location</td><td>Seek location </td></tr>
    <tr><td class="paramname">fromStart</td><td>true if seek location is reletive to song start, false if reletive to current position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the call succeeded, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad3d4939aca91bef956234f7ceaf35a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d4939aca91bef956234f7ceaf35a7d">&#9670;&nbsp;</a></span>setSource() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::setSource </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">avsCommon::avs::attachment::AttachmentReader</a> &gt;&#160;</td>
          <td class="paramname"><em>attachmentReader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_audio_format.html">avsCommon::utils::AudioFormat</a> *&#160;</td>
          <td class="paramname"><em>format</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_source_config.html">SourceConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html#a93b9bf962eedc9791f4bc1560e93e8e5">emptySourceConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set an <code>AttachmentReader</code> source to play. The source should be set before making calls to any of the playback control APIs. If any source was set prior to this call, that source will be discarded.</p>
<dl class="section note"><dt>Note</dt><dd>A <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html">MediaPlayerInterface</a></code> implementation must handle only one source at a time. An implementation must call <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#afb6430fd24bf5ecc85ba34e9fbb46a3b">MediaPlayerObserverInterface::onPlaybackStopped()</a></code> with the previous source's id if there was a source set. Also, an implementation must call <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a3b2a48421f88103f6e14c9ae530e251e">MediaPlayerObserverInterface::onBufferingComplete()</a></code> when this source has been fully buffered</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentReader</td><td>Object with which to read an incoming audio attachment. </td></tr>
    <tr><td class="paramname">format</td><td>The audioFormat to be used to interpret raw audio data. </td></tr>
    <tr><td class="paramname">config</td><td>Media configuration of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>SourceId</code> that represents the source being handled as a result of this call. <code>ERROR</code> will be returned if the source failed to be set. Must be unique across all instances. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1test_1_1_mock_media_player.html#a866064694d3b90405e820f3576a5f57d">alexaClientSDK::avsCommon::utils::mediaPlayer::test::MockMediaPlayer</a>.</p>

</div>
</div>
<a id="a5df17fc30e2ee59053cdaef64b021fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df17fc30e2ee59053cdaef64b021fe2">&#9670;&nbsp;</a></span>setSource() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::setSource </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">avsCommon::avs::attachment::AttachmentReader</a> &gt;&#160;</td>
          <td class="paramname"><em>attachmentReader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>offsetAdjustment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_audio_format.html">avsCommon::utils::AudioFormat</a> *&#160;</td>
          <td class="paramname"><em>format</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_source_config.html">SourceConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html#a93b9bf962eedc9791f4bc1560e93e8e5">emptySourceConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set an <code>AttachmentReader</code> source to play. The source should be set before making calls to any of the playback control APIs. If any source was set prior to this call, that source will be discarded.</p>
<dl class="section note"><dt>Note</dt><dd>A <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html">MediaPlayerInterface</a></code> implementation must handle only one source at a time. An implementation must call <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#afb6430fd24bf5ecc85ba34e9fbb46a3b">MediaPlayerObserverInterface::onPlaybackStopped()</a></code> with the previous source's id if there was a source set. Also, an implementation must call <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a3b2a48421f88103f6e14c9ae530e251e">MediaPlayerObserverInterface::onBufferingComplete()</a></code> when this source has been fully buffered</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentReader</td><td>Object with which to read an incoming audio attachment. </td></tr>
    <tr><td class="paramname">format</td><td>The audioFormat to be used to interpret raw audio data. </td></tr>
    <tr><td class="paramname">offsetAdjustment</td><td>Offset adjustment required for the offset reported </td></tr>
    <tr><td class="paramname">config</td><td>Media configuration of source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>SourceId</code> that represents the source being handled as a result of this call. <code>ERROR</code> will be returned if the source failed to be set. Must be unique across all instances. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1test_1_1_mock_media_player.html#aef2b725c8e1d092139e275cdda7d368e">alexaClientSDK::avsCommon::utils::mediaPlayer::test::MockMediaPlayer</a>.</p>

</div>
</div>
<a id="a5baee600aab3cae55ea051cf411624f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5baee600aab3cae55ea051cf411624f4">&#9670;&nbsp;</a></span>setSource() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::setSource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>offset</em> = <code>std::chrono::milliseconds::zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_source_config.html">SourceConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html#a93b9bf962eedc9791f4bc1560e93e8e5">emptySourceConfig</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeat</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_playback_context.html">PlaybackContext</a> &amp;&#160;</td>
          <td class="paramname"><em>playbackContext</em> = <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_playback_context.html">PlaybackContext</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a url source to play. The source should be set before making calls to any of the playback control APIs. If any source was set prior to this call, that source will be discarded.</p>
<dl class="section note"><dt>Note</dt><dd>A <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html">MediaPlayerInterface</a></code> implementation must handle only one source at a time. An implementation must call <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#afb6430fd24bf5ecc85ba34e9fbb46a3b">MediaPlayerObserverInterface::onPlaybackStopped()</a></code> with the previous source's id if there was a source set. Also, an implementation must call <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a3b2a48421f88103f6e14c9ae530e251e">MediaPlayerObserverInterface::onBufferingComplete()</a></code> when this source has been fully buffered</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The url to set as the source. </td></tr>
    <tr><td class="paramname">offset</td><td>An optional offset parameter to start playing from when a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a></code> call is made. </td></tr>
    <tr><td class="paramname">config</td><td>Media configuration of source. </td></tr>
    <tr><td class="paramname">repeat</td><td>An optional parameter to play the url source in a loop. </td></tr>
    <tr><td class="paramname">playbackContext</td><td>An optional parameter used for sending headers needed for data requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>SourceId</code> that represents the source being handled as a result of this call. <code>ERROR</code> will be returned if the source failed to be set. Must be unique across all instances. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1acsdk_alerts_1_1renderer_1_1test_1_1_test_media_player.html#a26cbaf107536de9c1272453a85f72df2">alexaClientSDK::acsdkAlerts::renderer::test::TestMediaPlayer</a>, <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1test_1_1_mock_media_player.html#a8a084f51dc203509a579729e78d3b022">alexaClientSDK::avsCommon::utils::mediaPlayer::test::MockMediaPlayer</a>, <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#ac5bb2cbb5d238ae18517d5b841b0d11d">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1android_1_1_android_s_l_e_s_media_player.html#ad2e419095d3fdd83beea6db21f9a9a7f">alexaClientSDK::mediaPlayer::android::AndroidSLESMediaPlayer</a>.</p>

</div>
</div>
<a id="ab56654e0dc59b964a23b83ca9ef74d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56654e0dc59b964a23b83ca9ef74d37">&#9670;&nbsp;</a></span>setSource() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::setSource </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; std::istream &gt;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeat</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_source_config.html">SourceConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html#a93b9bf962eedc9791f4bc1560e93e8e5">emptySourceConfig</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils.html#a23c4c0b3872cf0413515899644d25924">avsCommon::utils::MediaType</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils.html#a23c4c0b3872cf0413515899644d25924a696b031073e74bf2cb98e5ef201d4aa3">avsCommon::utils::MediaType::UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set an <code>istream</code> source to play. The source should be set before making calls to any of the playback control APIs. If any source was set prior to this call, that source will be discarded.</p>
<dl class="section note"><dt>Note</dt><dd>A <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html">MediaPlayerInterface</a></code> implementation must handle only one source at a time. An implementation must call <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#afb6430fd24bf5ecc85ba34e9fbb46a3b">MediaPlayerObserverInterface::onPlaybackStopped()</a></code> with the previous source's id if there was a source set. Also, an implementation must call <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a3b2a48421f88103f6e14c9ae530e251e">MediaPlayerObserverInterface::onBufferingComplete()</a></code> when this source has been fully buffered</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Object from which to read an incoming audio stream. </td></tr>
    <tr><td class="paramname">repeat</td><td>Whether the audio stream should be played in a loop until stopped. </td></tr>
    <tr><td class="paramname">config</td><td>Media configuration of source. </td></tr>
    <tr><td class="paramname">format</td><td>The <code>MediaType</code> audio encoding format of the incoming audio stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>SourceId</code> that represents the source being handled as a result of this call. <code>ERROR</code> will be returned if the source failed to be set. Must be unique across all instances. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1acsdk_alerts_1_1renderer_1_1test_1_1_test_media_player.html#aa091e3c72bcf3cc8d5fbebe406bfd0b0">alexaClientSDK::acsdkAlerts::renderer::test::TestMediaPlayer</a>, <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1test_1_1_mock_media_player.html#ae652fe2b972ef0af386fd2353b591388">alexaClientSDK::avsCommon::utils::mediaPlayer::test::MockMediaPlayer</a>, <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#a55dbaaf09aff2d6b21ba6fc64dfdae5b">alexaClientSDK::mediaPlayer::MediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1android_1_1_android_s_l_e_s_media_player.html#a22dafcde7e4471a893522e80b50b835c">alexaClientSDK::mediaPlayer::android::AndroidSLESMediaPlayer</a>.</p>

</div>
</div>
<a id="a422503c5051d68fdab1485b74c0c33a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422503c5051d68fdab1485b74c0c33a1">&#9670;&nbsp;</a></span>stop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stops playing the audio specified by the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code> call.</p>
<p>The source must be set before issuing <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a422503c5051d68fdab1485b74c0c33a1">stop()</a></code>.</p>
<p>Once <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a422503c5051d68fdab1485b74c0c33a1">stop()</a></code> has been called, subsequent <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a></code> calls will fail. If <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a422503c5051d68fdab1485b74c0c33a1">stop()</a></code> is called when audio has already stopped, <code>false</code> will be returned. If the id does not match the id of the active source, then <code>false</code> will be returned. If the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a422503c5051d68fdab1485b74c0c33a1">stop()</a></code> succeeded, <code>true</code> will be returned. When <code>true</code> is returned, a callback will be made to either <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#afb6430fd24bf5ecc85ba34e9fbb46a3b">MediaPlayerObserverInterface::onPlaybackStopped()</a></code> or to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a9c42c6f619e28e888c56a51edcccd07c">MediaPlayerObserverInterface::onPlaybackError()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique id of the source on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the call succeeded, in which case a callback will be made, or <code>false</code> otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html#af8e1300838fcd41cef9a9bf2d18b5e9a">alexaClientSDK::mediaPlayer::MediaPlayer</a>, <a class="el" href="classalexa_client_s_d_k_1_1acsdk_alerts_1_1renderer_1_1test_1_1_test_media_player.html#a10da72b420dab0410c1f14b73c9e5482">alexaClientSDK::acsdkAlerts::renderer::test::TestMediaPlayer</a>, and <a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1android_1_1_android_s_l_e_s_media_player.html#a6214a40915be2de0657eea17203c8711">alexaClientSDK::mediaPlayer::android::AndroidSLESMediaPlayer</a>.</p>

</div>
</div>
<a id="a6bfc7029b2be6e2c756bf09dcf94de22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfc7029b2be6e2c756bf09dcf94de22">&#9670;&nbsp;</a></span>stop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::seconds&#160;</td>
          <td class="paramname"><em>timeToPipelineShutdown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stops playing the audio specified by the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code> call, but will keep the pipeline open for a set time. NOTE: This call is optional, and may not be implemented by all MediaPlayers</p>
<p>The source must be set before issuing <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a422503c5051d68fdab1485b74c0c33a1">stop()</a></code>.</p>
<p>Once <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a422503c5051d68fdab1485b74c0c33a1">stop()</a></code> has been called, and the pipeline has shutdown, subsequent <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a></code> calls will fail. However, if <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a></code> is called while the pipeline remains open, playback will continue from the stopped location, or, if <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2cc2c8df7870510380a2a3e3946b72d8">seekTo()</a></code> is called while the pipeline is open, and <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2bd648268d8afaf23312dad7e21238ad">play()</a></code> also called while the pipeline is open, then playback will resume from the location specified in the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a2cc2c8df7870510380a2a3e3946b72d8">seekTo()</a></code> call. If <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a422503c5051d68fdab1485b74c0c33a1">stop()</a></code> is called when audio has already stopped, <code>false</code> will be returned. If the id does not match the id of the active source, then <code>false</code> will be returned. If the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a422503c5051d68fdab1485b74c0c33a1">stop()</a></code> succeeded, <code>true</code> will be returned. When <code>true</code> is returned, a callback will be made to either <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#afb6430fd24bf5ecc85ba34e9fbb46a3b">MediaPlayerObserverInterface::onPlaybackStopped()</a></code> or to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a9c42c6f619e28e888c56a51edcccd07c">MediaPlayerObserverInterface::onPlaybackError()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique id of the source on which to operate. </td></tr>
    <tr><td class="paramname">timeToPipelineShutdown</td><td>The pipeline will be kept open for this long, and during that time, a call to  will resume playback from the stopped location (or seeked location, if seek is called)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the call succeeded, in which case a callback will be made, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a94e049f4cbbd174ef8e6c15387dd85ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e049f4cbbd174ef8e6c15387dd85ea">&#9670;&nbsp;</a></span>ERROR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">SourceId</a> alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerInterface::ERROR = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An <code>SourceId</code> used to represent an error from calls to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#ad3d4939aca91bef956234f7ceaf35a7d">setSource()</a></code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/workplace/avs-device-sdk/AVSCommon/Utils/include/AVSCommon/Utils/MediaPlayer/<a class="el" href="_media_player_interface_8h_source.html">MediaPlayerInterface.h</a></li>
</ul>
</div><!-- contents -->
<html>
  <body>
    <p style="text-align:left;">
      AlexaClientSDK 3.0.0 - Copyright 2016-2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
      <span style="float:right;">
	Licensed under the <a HREF=http://aws.amazon.com/apache2.0/>Apache License, Version 2.0</a>
      </span>
    </p>
  </body>
</html>
