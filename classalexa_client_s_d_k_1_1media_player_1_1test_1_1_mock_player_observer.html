<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AlexaClientSDK: alexaClientSDK::mediaPlayer::test::MockPlayerObserver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="avs-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AlexaClientSDK
   &#160;<span id="projectnumber">1.20.1</span>
   </div>
   <div id="projectbrief">A cross-platform, modular SDK for interacting with the Alexa Voice Service</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacealexa_client_s_d_k.html">alexaClientSDK</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1media_player.html">mediaPlayer</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1media_player_1_1test.html">test</a></li><li class="navelem"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html">MockPlayerObserver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">alexaClientSDK::mediaPlayer::test::MockPlayerObserver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for alexaClientSDK::mediaPlayer::test::MockPlayerObserver:</div>
<div class="dyncontent">
<div class="center"><img src="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer__inherit__graph.png" border="0" usemap="#alexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer_inherit__map" alt="Inheritance graph"/></div>
<map name="alexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer_inherit__map" id="alexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer_inherit__map">
<area shape="rect" id="node2" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html" title="alexaClientSDK::avsCommon\l::utils::mediaPlayer::MediaPlayer\lObserverInterface" alt="" coords="5,5,220,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for alexaClientSDK::mediaPlayer::test::MockPlayerObserver:</div>
<div class="dyncontent">
<div class="center"><img src="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer__coll__graph.png" border="0" usemap="#alexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer_coll__map" alt="Collaboration graph"/></div>
<map name="alexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer_coll__map" id="alexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer_coll__map">
<area shape="rect" id="node2" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html" title="alexaClientSDK::avsCommon\l::utils::mediaPlayer::MediaPlayer\lObserverInterface" alt="" coords="5,5,220,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6fd8e0ddd362034fce2ec90b29d8c2c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a6fd8e0ddd362034fce2ec90b29d8c2c0">~MockPlayerObserver</a> ()</td></tr>
<tr class="separator:a6fd8e0ddd362034fce2ec90b29d8c2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462a049f365d89c3538c8a203e6d45b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a462a049f365d89c3538c8a203e6d45b2">onPlaybackStarted</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;state) override</td></tr>
<tr class="separator:a462a049f365d89c3538c8a203e6d45b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f639e56a72c19d8b8ff345a5082a33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a24f639e56a72c19d8b8ff345a5082a33">onPlaybackFinished</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;state) override</td></tr>
<tr class="separator:a24f639e56a72c19d8b8ff345a5082a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711c33c2b125432e0ac4140298c6f245"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a711c33c2b125432e0ac4140298c6f245">onPlaybackError</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const <a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html#ab6ff57ee3fc3650d3b710fa12d32e25d">ErrorType</a> &amp;type, std::string error, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;state) override</td></tr>
<tr class="separator:a711c33c2b125432e0ac4140298c6f245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302c6a398f1a31451efbe48c45f9079c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a302c6a398f1a31451efbe48c45f9079c">onPlaybackPaused</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;state) override</td></tr>
<tr class="separator:a302c6a398f1a31451efbe48c45f9079c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737f9775b5f0643ac30a133326716724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a737f9775b5f0643ac30a133326716724">onPlaybackResumed</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;state) override</td></tr>
<tr class="separator:a737f9775b5f0643ac30a133326716724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afb9ad50165cf60810af593038d42d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a8afb9ad50165cf60810af593038d42d0">onPlaybackStopped</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;state) override</td></tr>
<tr class="separator:a8afb9ad50165cf60810af593038d42d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a34950e9b03a4161dbd0c86adcd1816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a7a34950e9b03a4161dbd0c86adcd1816">onBufferingComplete</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;state) override</td></tr>
<tr class="separator:a7a34950e9b03a4161dbd0c86adcd1816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4a823743abf246fb5e9a77b341a895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#abf4a823743abf246fb5e9a77b341a895">onTags</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, std::unique_ptr&lt; const <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#aaa78c5d6cb74fc05e7abbe8201fd02ad">VectorOfTags</a> &gt; vectorOfTags, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;state) override</td></tr>
<tr class="separator:abf4a823743abf246fb5e9a77b341a895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13670ae4d0cc3b5e06ee6da13268411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#aa13670ae4d0cc3b5e06ee6da13268411">onFirstByteRead</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;state) override</td></tr>
<tr class="separator:aa13670ae4d0cc3b5e06ee6da13268411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667e1593818a521c2c40ca9b6ae3ffb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a667e1593818a521c2c40ca9b6ae3ffb3">waitForPlaybackStarted</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const std::chrono::milliseconds duration=std::chrono::milliseconds(5000))</td></tr>
<tr class="separator:a667e1593818a521c2c40ca9b6ae3ffb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbab7a22727cd9a0530d72b7320e7417"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#adbab7a22727cd9a0530d72b7320e7417">waitForPlaybackFinished</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const std::chrono::milliseconds duration=std::chrono::milliseconds(5000))</td></tr>
<tr class="separator:adbab7a22727cd9a0530d72b7320e7417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad138e3dca8082997af63806bf20af43b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#ad138e3dca8082997af63806bf20af43b">waitForPlaybackPaused</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const std::chrono::milliseconds duration=std::chrono::milliseconds(5000))</td></tr>
<tr class="separator:ad138e3dca8082997af63806bf20af43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8895ba517efd327fe048b4e644cd856"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#ab8895ba517efd327fe048b4e644cd856">waitForPlaybackResumed</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const std::chrono::milliseconds duration=std::chrono::milliseconds(5000))</td></tr>
<tr class="separator:ab8895ba517efd327fe048b4e644cd856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9c096cc0f84bd32fdde771ff34f1ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a9a9c096cc0f84bd32fdde771ff34f1ac">waitForPlaybackStopped</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const std::chrono::milliseconds duration=std::chrono::milliseconds(5000))</td></tr>
<tr class="separator:a9a9c096cc0f84bd32fdde771ff34f1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd26049c6d065ea4b399072cb9bef5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a3dd26049c6d065ea4b399072cb9bef5a">waitForPlaybackError</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const std::chrono::milliseconds duration=std::chrono::milliseconds(5000))</td></tr>
<tr class="separator:a3dd26049c6d065ea4b399072cb9bef5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a22cda25077eec22f4b60bf013b65da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a1a22cda25077eec22f4b60bf013b65da">waitForBufferingComplete</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const std::chrono::milliseconds duration=std::chrono::milliseconds(5000))</td></tr>
<tr class="separator:a1a22cda25077eec22f4b60bf013b65da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8e17572f2ba2c6f536e7f8bb9f5dd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a9e8e17572f2ba2c6f536e7f8bb9f5dd6">waitForTags</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> id, const std::chrono::milliseconds duration=std::chrono::milliseconds(5000))</td></tr>
<tr class="separator:a9e8e17572f2ba2c6f536e7f8bb9f5dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ed84837a9cbc850b969e69b3c3f541"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#aa4ed84837a9cbc850b969e69b3c3f541">getOnPlaybackStartedCallCount</a> ()</td></tr>
<tr class="separator:aa4ed84837a9cbc850b969e69b3c3f541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732426f1ba0007ea081ab94dd268a634"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a732426f1ba0007ea081ab94dd268a634">getOnPlaybackFinishedCallCount</a> ()</td></tr>
<tr class="separator:a732426f1ba0007ea081ab94dd268a634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff1ae372cb05d5c492b9814b7a1f13e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1test_1_1_mock_player_observer.html#a6ff1ae372cb05d5c492b9814b7a1f13e">getOnTagsCallCount</a> ()</td></tr>
<tr class="separator:a6ff1ae372cb05d5c492b9814b7a1f13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a></td></tr>
<tr class="memitem:a98a4b7578480d29f86b2d7868080200e inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a98a4b7578480d29f86b2d7868080200e">~MediaPlayerObserverInterface</a> ()=default</td></tr>
<tr class="separator:a98a4b7578480d29f86b2d7868080200e inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78319364b0a5bb4bba7ee802872935e6 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a78319364b0a5bb4bba7ee802872935e6">onBufferUnderrun</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;)</td></tr>
<tr class="separator:a78319364b0a5bb4bba7ee802872935e6 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d19c34b8ef5b9f5a95446dbf64a3b1 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a87d19c34b8ef5b9f5a95446dbf64a3b1">onBufferRefilled</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;)</td></tr>
<tr class="separator:a87d19c34b8ef5b9f5a95446dbf64a3b1 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad957173c96529c293ded5bea46929052 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad957173c96529c293ded5bea46929052">onSeeked</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;, const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;)</td></tr>
<tr class="separator:ad957173c96529c293ded5bea46929052 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a></td></tr>
<tr class="memitem:ab8bd9f2e13a80beba778f9effcf768f9 inherit pub_types_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ab8bd9f2e13a80beba778f9effcf768f9">TagType</a> { <br />
&#160;&#160;<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ab8bd9f2e13a80beba778f9effcf768f9a63b588d5559f64f89a416e656880b949">TagType::STRING</a>, 
<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ab8bd9f2e13a80beba778f9effcf768f9a3351504090a741e69da641a42e00da80">TagType::UINT</a>, 
<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ab8bd9f2e13a80beba778f9effcf768f9a53f93baa3057821107c750323892fa92">TagType::INT</a>, 
<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ab8bd9f2e13a80beba778f9effcf768f9afd3e4ece78a7d422280d5ed379482229">TagType::DOUBLE</a>, 
<br />
&#160;&#160;<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ab8bd9f2e13a80beba778f9effcf768f9ac48d5da12d702e73d6966069f2687376">TagType::BOOLEAN</a>
<br />
 }<tr class="memdesc:ab8bd9f2e13a80beba778f9effcf768f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different types of metadata "stream tags".  <a href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ab8bd9f2e13a80beba778f9effcf768f9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab8bd9f2e13a80beba778f9effcf768f9 inherit pub_types_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a5305efc05863a6c2d49a2f40551f7 inherit pub_types_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a> = <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_interface.html#a97b83ae4aaeabff7bb8a796a8a018623">MediaPlayerInterface::SourceId</a></td></tr>
<tr class="memdesc:ad6a5305efc05863a6c2d49a2f40551f7 inherit pub_types_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that identifies which source is currently being operated on.  <a href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">More...</a><br /></td></tr>
<tr class="separator:ad6a5305efc05863a6c2d49a2f40551f7 inherit pub_types_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa78c5d6cb74fc05e7abbe8201fd02ad inherit pub_types_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface_1_1_tag_key_value_type.html">TagKeyValueType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#aaa78c5d6cb74fc05e7abbe8201fd02ad">VectorOfTags</a></td></tr>
<tr class="separator:aaa78c5d6cb74fc05e7abbe8201fd02ad inherit pub_types_classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6fd8e0ddd362034fce2ec90b29d8c2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd8e0ddd362034fce2ec90b29d8c2c0">&#9670;&nbsp;</a></span>~MockPlayerObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">alexaClientSDK::mediaPlayer::test::MockPlayerObserver::~MockPlayerObserver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a732426f1ba0007ea081ab94dd268a634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732426f1ba0007ea081ab94dd268a634">&#9670;&nbsp;</a></span>getOnPlaybackFinishedCallCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int alexaClientSDK::mediaPlayer::test::MockPlayerObserver::getOnPlaybackFinishedCallCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO: Make this class a mock and remove this.</p>
<p>This gets the number of times onPlaybackFinished was called. </p>

</div>
</div>
<a id="aa4ed84837a9cbc850b969e69b3c3f541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ed84837a9cbc850b969e69b3c3f541">&#9670;&nbsp;</a></span>getOnPlaybackStartedCallCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int alexaClientSDK::mediaPlayer::test::MockPlayerObserver::getOnPlaybackStartedCallCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO: Make this class a mock and remove this.</p>
<p>This gets the number of times onPlaybackStarted was called. </p>

</div>
</div>
<a id="a6ff1ae372cb05d5c492b9814b7a1f13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff1ae372cb05d5c492b9814b7a1f13e">&#9670;&nbsp;</a></span>getOnTagsCallCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int alexaClientSDK::mediaPlayer::test::MockPlayerObserver::getOnTagsCallCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO: Make this class a mock and remove this.</p>
<p>This gets the number of times onTags was called. </p>

</div>
</div>
<a id="a7a34950e9b03a4161dbd0c86adcd1816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a34950e9b03a4161dbd0c86adcd1816">&#9670;&nbsp;</a></span>onBufferingComplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::test::MockPlayerObserver::onBufferingComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an indication to the observer that the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> has completed buffering of the source specified by the id. This can be sent anytime after a source is set. This notification is part of <code>AudioPlayer's</code> implementation for pre-buffering, and must be called by <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> implementations for this feature to work properly.</p>
<dl class="section note"><dt>Note</dt><dd>The observer must quickly return from this callback. Failure to do so could block the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> from further processing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceId</td><td>The id of the source to which this callback corresponds to. </td></tr>
    <tr><td class="paramname">MediaPlayerState</td><td>Metadata about the media player state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a3b2a48421f88103f6e14c9ae530e251e">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a>.</p>

</div>
</div>
<a id="aa13670ae4d0cc3b5e06ee6da13268411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13670ae4d0cc3b5e06ee6da13268411">&#9670;&nbsp;</a></span>onFirstByteRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::test::MockPlayerObserver::onFirstByteRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an indication to the observer that the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> has read its first byte of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the source to which this callback corresponds to. </td></tr>
    <tr><td class="paramname">state</td><td>Metadata about the media player state </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a4619ade3b353145ba614201da0000f29">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a>.</p>

</div>
</div>
<a id="a711c33c2b125432e0ac4140298c6f245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711c33c2b125432e0ac4140298c6f245">&#9670;&nbsp;</a></span>onPlaybackError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::test::MockPlayerObserver::onPlaybackError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player.html#ab6ff57ee3fc3650d3b710fa12d32e25d">ErrorType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an indication to the observer that the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> encountered an error. Errors can occur during playback.</p>
<dl class="section note"><dt>Note</dt><dd>The observer must quickly return from this callback. Failure to do so could block the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> from further processing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the source to which this callback corresponds to. </td></tr>
    <tr><td class="paramname">type</td><td>The type of error encountered by the <code>MediaPlayerInterface</code>. </td></tr>
    <tr><td class="paramname">error</td><td>The error encountered by the <code>MediaPlayerInterface</code>. </td></tr>
    <tr><td class="paramname">state</td><td>Metadata about the media player state </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a9c42c6f619e28e888c56a51edcccd07c">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a>.</p>

</div>
</div>
<a id="a24f639e56a72c19d8b8ff345a5082a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f639e56a72c19d8b8ff345a5082a33">&#9670;&nbsp;</a></span>onPlaybackFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::test::MockPlayerObserver::onPlaybackFinished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an indication to the observer that the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> finished the source.</p>
<dl class="section note"><dt>Note</dt><dd>The observer must quickly return to quickly from this callback. Failure to do so could block the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> from further processing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the source to which this callback corresponds to. </td></tr>
    <tr><td class="paramname">state</td><td>Metadata about the media player state </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a110f88bafaf1818d58f3f0ebb68608b3">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a>.</p>

</div>
</div>
<a id="a302c6a398f1a31451efbe48c45f9079c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302c6a398f1a31451efbe48c45f9079c">&#9670;&nbsp;</a></span>onPlaybackPaused()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::test::MockPlayerObserver::onPlaybackPaused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an indication to the observer that the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> has paused playing the source.</p>
<dl class="section note"><dt>Note</dt><dd>The observer must quickly return from this callback. Failure to do so could block the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> from further processing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceId</td><td>The id of the source to which this callback corresponds to. </td></tr>
    <tr><td class="paramname">MediaPlayerState</td><td>Metadata about the media player state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#af20f86b9956188ce46efbc59dc2e648d">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a>.</p>

</div>
</div>
<a id="a737f9775b5f0643ac30a133326716724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737f9775b5f0643ac30a133326716724">&#9670;&nbsp;</a></span>onPlaybackResumed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::test::MockPlayerObserver::onPlaybackResumed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an indication to the observer that the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> has resumed playing the source.</p>
<dl class="section note"><dt>Note</dt><dd>The observer must quickly return from this callback. Failure to do so could block the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> from further processing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceId</td><td>The id of the source to which this callback corresponds to. </td></tr>
    <tr><td class="paramname">MediaPlayerState</td><td>Metadata about the media player state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a13efb5dc6fb13418ba67221b2c9ea936">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a>.</p>

</div>
</div>
<a id="a462a049f365d89c3538c8a203e6d45b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462a049f365d89c3538c8a203e6d45b2">&#9670;&nbsp;</a></span>onPlaybackStarted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::test::MockPlayerObserver::onPlaybackStarted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an indication to the observer that the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> has started playing the source specified by the id.</p>
<dl class="section note"><dt>Note</dt><dd>The observer must quickly return to quickly from this callback. Failure to do so could block the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> from further processing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the source to which this callback corresponds to. </td></tr>
    <tr><td class="paramname">state</td><td>Metadata about the media player state </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a423d815f2188441452e0cd8ea955ae87">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a>.</p>

</div>
</div>
<a id="a8afb9ad50165cf60810af593038d42d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afb9ad50165cf60810af593038d42d0">&#9670;&nbsp;</a></span>onPlaybackStopped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::test::MockPlayerObserver::onPlaybackStopped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an indication to the observer that the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> has stopped the source.</p>
<dl class="section note"><dt>Note</dt><dd>The observer must quickly return from this callback. Failure to do so could block the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> from further processing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceId</td><td>The id of the source to which this callback corresponds to. </td></tr>
    <tr><td class="paramname">MediaPlayerState</td><td>Metadata about the media player state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#afb6430fd24bf5ecc85ba34e9fbb46a3b">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a>.</p>

</div>
</div>
<a id="abf4a823743abf246fb5e9a77b341a895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4a823743abf246fb5e9a77b341a895">&#9670;&nbsp;</a></span>onTags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::mediaPlayer::test::MockPlayerObserver::onTags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; const <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#aaa78c5d6cb74fc05e7abbe8201fd02ad">VectorOfTags</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_state.html">MediaPlayerState</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an indication to the observer that the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> has found tags in the stream. Tags are key value pairs extracted from the metadata of the stream. There can be multiple tags that have the same key. Vector preserves the order of insertion (push_back) which may come in handy.</p>
<dl class="section note"><dt>Note</dt><dd>The observer must quickly returnfrom this callback. Failure to do so could block the <code><a class="el" href="classalexa_client_s_d_k_1_1media_player_1_1_media_player.html">MediaPlayer</a></code> from further processing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceId</td><td>The id of the source to which this callback corresponds to. </td></tr>
    <tr><td class="paramname">VectorOfTags</td><td>The vector containing stream tags. </td></tr>
    <tr><td class="paramname">MediaPlayerState</td><td>Metadata about the media player state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#a6c5ae0e357ebdd18edd0b1cccb74f5c8">alexaClientSDK::avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface</a>.</p>

</div>
</div>
<a id="a1a22cda25077eec22f4b60bf013b65da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a22cda25077eec22f4b60bf013b65da">&#9670;&nbsp;</a></span>waitForBufferingComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::mediaPlayer::test::MockPlayerObserver::waitForBufferingComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::milliseconds(5000)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a buffering complete message to be received.</p>
<p>This function waits for a specified number of milliseconds for a message to arrive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The <code>SourceId</code> expected in a callback. </td></tr>
    <tr><td class="paramname">duration</td><td>Number of milliseconds to wait before giving up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was received within the specified duration, else false. </dd></dl>

</div>
</div>
<a id="a3dd26049c6d065ea4b399072cb9bef5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd26049c6d065ea4b399072cb9bef5a">&#9670;&nbsp;</a></span>waitForPlaybackError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::mediaPlayer::test::MockPlayerObserver::waitForPlaybackError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::milliseconds(5000)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a playback error message to be received.</p>
<p>This function waits for a specified number of milliseconds for a message to arrive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The <code>SourceId</code> expected in a callback. </td></tr>
    <tr><td class="paramname">duration</td><td>Number of milliseconds to wait before giving up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was received within the specified duration, else false. </dd></dl>

</div>
</div>
<a id="adbab7a22727cd9a0530d72b7320e7417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbab7a22727cd9a0530d72b7320e7417">&#9670;&nbsp;</a></span>waitForPlaybackFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::mediaPlayer::test::MockPlayerObserver::waitForPlaybackFinished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::milliseconds(5000)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a message to be received.</p>
<p>This function waits for a specified number of milliseconds for a message to arrive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The <code>SourceId</code> expected in a callback. </td></tr>
    <tr><td class="paramname">duration</td><td>Number of milliseconds to wait before giving up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was received within the specified duration, else false. </dd></dl>

</div>
</div>
<a id="ad138e3dca8082997af63806bf20af43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad138e3dca8082997af63806bf20af43b">&#9670;&nbsp;</a></span>waitForPlaybackPaused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::mediaPlayer::test::MockPlayerObserver::waitForPlaybackPaused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::milliseconds(5000)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a message to be received.</p>
<p>This function waits for a specified number of milliseconds for a message to arrive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The <code>SourceId</code> expected in a callback. </td></tr>
    <tr><td class="paramname">duration</td><td>Number of milliseconds to wait before giving up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was received within the specified duration, else false. </dd></dl>

</div>
</div>
<a id="ab8895ba517efd327fe048b4e644cd856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8895ba517efd327fe048b4e644cd856">&#9670;&nbsp;</a></span>waitForPlaybackResumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::mediaPlayer::test::MockPlayerObserver::waitForPlaybackResumed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::milliseconds(5000)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a message to be received.</p>
<p>This function waits for a specified number of milliseconds for a message to arrive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The <code>SourceId</code> expected in a callback. </td></tr>
    <tr><td class="paramname">duration</td><td>Number of milliseconds to wait before giving up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was received within the specified duration, else false. </dd></dl>

</div>
</div>
<a id="a667e1593818a521c2c40ca9b6ae3ffb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667e1593818a521c2c40ca9b6ae3ffb3">&#9670;&nbsp;</a></span>waitForPlaybackStarted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::mediaPlayer::test::MockPlayerObserver::waitForPlaybackStarted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::milliseconds(5000)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a message to be received.</p>
<p>This function waits for a specified number of milliseconds for a message to arrive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The <code>SourceId</code> expected in a callback. </td></tr>
    <tr><td class="paramname">duration</td><td>Number of milliseconds to wait before giving up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was received within the specified duration, else false. </dd></dl>

</div>
</div>
<a id="a9a9c096cc0f84bd32fdde771ff34f1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9c096cc0f84bd32fdde771ff34f1ac">&#9670;&nbsp;</a></span>waitForPlaybackStopped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::mediaPlayer::test::MockPlayerObserver::waitForPlaybackStopped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::milliseconds(5000)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a message to be received.</p>
<p>This function waits for a specified number of milliseconds for a message to arrive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The <code>SourceId</code> expected in a callback. </td></tr>
    <tr><td class="paramname">duration</td><td>Number of milliseconds to wait before giving up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was received within the specified duration, else false. </dd></dl>

</div>
</div>
<a id="a9e8e17572f2ba2c6f536e7f8bb9f5dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8e17572f2ba2c6f536e7f8bb9f5dd6">&#9670;&nbsp;</a></span>waitForTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::mediaPlayer::test::MockPlayerObserver::waitForTags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1media_player_1_1_media_player_observer_interface.html#ad6a5305efc05863a6c2d49a2f40551f7">SourceId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::milliseconds(5000)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a message to be received. This function waits for a specified number of milliseconds for a message to arrive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The <code>SourceId</code> expected in a callback. </td></tr>
    <tr><td class="paramname">duration</td><td>Number of milliseconds to wait before giving up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message was received within the specified duration, else false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/workplace/avs-device-sdk/MediaPlayer/GStreamerMediaPlayer/test/<a class="el" href="_media_player_test_8cpp.html">MediaPlayerTest.cpp</a></li>
</ul>
</div><!-- contents -->
<html>
  <body>
    <p style="text-align:left;">
      AlexaClientSDK 1.20.1 - Copyright 2016-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
      <span style="float:right;">
	Licensed under the <a HREF=http://aws.amazon.com/apache2.0/>Apache License, Version 2.0</a>
      </span>
    </p>
  </body>
</html>
