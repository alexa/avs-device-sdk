<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AlexaClientSDK: alexaClientSDK::avsCommon::avs::MessageRequest Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="avs-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AlexaClientSDK
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">A cross-platform, modular SDK for interacting with the Alexa Voice Service</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacealexa_client_s_d_k.html">alexaClientSDK</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common.html">avsCommon</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1avs.html">avs</a></li><li class="navelem"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">alexaClientSDK::avsCommon::avs::MessageRequest Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_message_request_8h_source.html">MessageRequest.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for alexaClientSDK::avsCommon::avs::MessageRequest:</div>
<div class="dyncontent">
<div class="center"><img src="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request__inherit__graph.png" border="0" usemap="#alexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_inherit__map" alt="Inheritance graph"/></div>
<map name="alexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_inherit__map" id="alexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_inherit__map">
<area shape="rect" id="node2" href="classalexa_client_s_d_k_1_1acl_1_1test_1_1_mock_message_request.html" title="alexaClientSDK::acl\l::test::MockMessageRequest" alt="" coords="273,5,467,47"/>
<area shape="rect" id="node3" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_editable_message_request.html" title="alexaClientSDK::avsCommon\l::avs::EditableMessageRequest" alt="" coords="266,71,474,112"/>
<area shape="rect" id="node4" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_waitable_message_request.html" title="alexaClientSDK::avsCommon\l::avs::WaitableMessageRequest" alt="" coords="264,136,476,177"/>
<area shape="rect" id="node5" href="classalexa_client_s_d_k_1_1capability_agents_1_1do_not_disturb_1_1_d_n_d_message_request.html" title="alexaClientSDK::capability\lAgents::doNotDisturb::DNDMessage\lRequest" alt="" coords="251,202,489,258"/>
<area shape="rect" id="node6" href="classalexa_client_s_d_k_1_1capability_agents_1_1playback_controller_1_1_playback_message_request.html" title="alexaClientSDK::capability\lAgents::playbackController\l::PlaybackMessageRequest" alt="" coords="277,282,463,338"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_event_headers.html">EventHeaders</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to hold event namespace and name.  <a href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_event_headers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_named_reader.html">NamedReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to hold an <code>AttachmentReader</code> alongside its name.  <a href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_named_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aef0454cedb3c097a3c2701fee718ef38"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#aef0454cedb3c097a3c2701fee718ef38">MessageRequestResolveFunction</a> = std::function&lt; bool(const std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_editable_message_request.html">EditableMessageRequest</a> &gt; &amp;req, const std::string &amp;resolveKey)&gt;</td></tr>
<tr class="separator:aef0454cedb3c097a3c2701fee718ef38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a269bdec60ec3c6b4b0cf4d81ca0468d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a269bdec60ec3c6b4b0cf4d81ca0468d6">MessageRequest</a> (const std::string &amp;jsonContent, const std::string &amp;uriPathExtension=&quot;&quot;, const unsigned int threshold=0, const std::string &amp;streamMetricName=&quot;&quot;)</td></tr>
<tr class="separator:a269bdec60ec3c6b4b0cf4d81ca0468d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bedccff5260f1d06281f775c4d0acf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a60bedccff5260f1d06281f775c4d0acf">MessageRequest</a> (const std::string &amp;jsonContent, const unsigned int threshold, const std::string &amp;streamMetricName)</td></tr>
<tr class="separator:a60bedccff5260f1d06281f775c4d0acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78858e1d0c2e637c97aecba08ccf4e23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a78858e1d0c2e637c97aecba08ccf4e23">MessageRequest</a> (const std::string &amp;jsonContent, bool isSerialized, const std::string &amp;uriPathExtension=&quot;&quot;, std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt; headers={}, <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#aef0454cedb3c097a3c2701fee718ef38">MessageRequestResolveFunction</a> resolver=nullptr, const unsigned int threshold=0, const std::string &amp;streamMetricName=&quot;&quot;)</td></tr>
<tr class="separator:a78858e1d0c2e637c97aecba08ccf4e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93eed92b60d6e2681db5f6500b99a89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#ab93eed92b60d6e2681db5f6500b99a89">MessageRequest</a> (const <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a> &amp;messageRequest)</td></tr>
<tr class="separator:ab93eed92b60d6e2681db5f6500b99a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c8ce94cf135b8c0959174a1c33e3e3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a11c8ce94cf135b8c0959174a1c33e3e3">~MessageRequest</a> ()</td></tr>
<tr class="separator:a11c8ce94cf135b8c0959174a1c33e3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6ff7cc1d2b684a16ea33e706b5600e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a7f6ff7cc1d2b684a16ea33e706b5600e">addAttachmentReader</a> (const std::string &amp;name, std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">attachment::AttachmentReader</a> &gt; attachmentReader)</td></tr>
<tr class="separator:a7f6ff7cc1d2b684a16ea33e706b5600e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbdfec53d194ffb82690bd8fa87d4e7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a8bbdfec53d194ffb82690bd8fa87d4e7">getJsonContent</a> () const</td></tr>
<tr class="separator:a8bbdfec53d194ffb82690bd8fa87d4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576d7a73b22a7e21adca66f154c42780"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a576d7a73b22a7e21adca66f154c42780">getIsSerialized</a> () const</td></tr>
<tr class="separator:a576d7a73b22a7e21adca66f154c42780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa82056f56c5a6d8d39ce73743c519b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a1fa82056f56c5a6d8d39ce73743c519b">getUriPathExtension</a> () const</td></tr>
<tr class="separator:a1fa82056f56c5a6d8d39ce73743c519b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64339a63366cccdc2035b41717d4e2fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a64339a63366cccdc2035b41717d4e2fb">attachmentReadersCount</a> () const</td></tr>
<tr class="separator:a64339a63366cccdc2035b41717d4e2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9f5dd4f64acd9cb8986eb3b7095b25"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_named_reader.html">NamedReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#aeb9f5dd4f64acd9cb8986eb3b7095b25">getAttachmentReader</a> (size_t index) const</td></tr>
<tr class="separator:aeb9f5dd4f64acd9cb8986eb3b7095b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35914042b8aee72a25243d241937556"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#aa35914042b8aee72a25243d241937556">responseStatusReceived</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_message_request_observer_interface.html#a29e40517f71dfc83e3159a8f0f489d7b">avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status</a> status)</td></tr>
<tr class="separator:aa35914042b8aee72a25243d241937556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71521a1ba3d1ace735798190c5059e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#ac71521a1ba3d1ace735798190c5059e5">sendCompleted</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_message_request_observer_interface.html#a29e40517f71dfc83e3159a8f0f489d7b">avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status</a> status)</td></tr>
<tr class="separator:ac71521a1ba3d1ace735798190c5059e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd8629bc9d5369b0a9c7b041c441fa2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#aacd8629bc9d5369b0a9c7b041c441fa2">exceptionReceived</a> (const std::string &amp;exceptionMessage)</td></tr>
<tr class="separator:aacd8629bc9d5369b0a9c7b041c441fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a451c99ee5d47c639e89b668e7830f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#ad0a451c99ee5d47c639e89b668e7830f">addObserver</a> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_message_request_observer_interface.html">avsCommon::sdkInterfaces::MessageRequestObserverInterface</a> &gt; observer)</td></tr>
<tr class="separator:ad0a451c99ee5d47c639e89b668e7830f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fe3acc9b87911b14fb4a10d98d6dda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a31fe3acc9b87911b14fb4a10d98d6dda">removeObserver</a> (std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_message_request_observer_interface.html">avsCommon::sdkInterfaces::MessageRequestObserverInterface</a> &gt; observer)</td></tr>
<tr class="separator:a31fe3acc9b87911b14fb4a10d98d6dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15b73d5036d673b5530d84f394d0eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_event_headers.html">EventHeaders</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#ac15b73d5036d673b5530d84f394d0eb8">retrieveEventHeaders</a> () const</td></tr>
<tr class="separator:ac15b73d5036d673b5530d84f394d0eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504d3ce1f7ed9361abb21ebf89cad915"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a504d3ce1f7ed9361abb21ebf89cad915">getHeaders</a> () const</td></tr>
<tr class="separator:a504d3ce1f7ed9361abb21ebf89cad915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a451de93434914abb29201c5c5d430"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a35a451de93434914abb29201c5c5d430">isResolved</a> () const</td></tr>
<tr class="separator:a35a451de93434914abb29201c5c5d430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1289e5b067fb754b4729ce09b951e58c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a1289e5b067fb754b4729ce09b951e58c">resolveRequest</a> (const std::string &amp;resolveKey) const</td></tr>
<tr class="separator:a1289e5b067fb754b4729ce09b951e58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5e3ddd4980d432b6572ca93f20e37b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a5b5e3ddd4980d432b6572ca93f20e37b">getStreamBytesThreshold</a> () const</td></tr>
<tr class="separator:a5b5e3ddd4980d432b6572ca93f20e37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2ba4b1b576aad958c06f6f0f19a5a4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#afc2ba4b1b576aad958c06f6f0f19a5a4">getStreamMetricName</a> () const</td></tr>
<tr class="separator:afc2ba4b1b576aad958c06f6f0f19a5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a423d6a102e3d537ccb4b56d185a14bf8"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a423d6a102e3d537ccb4b56d185a14bf8">m_observerMutex</a></td></tr>
<tr class="memdesc:a423d6a102e3d537ccb4b56d185a14bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to guard access of m_observers.  <a href="#a423d6a102e3d537ccb4b56d185a14bf8">More...</a><br /></td></tr>
<tr class="separator:a423d6a102e3d537ccb4b56d185a14bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b78688c70a3a33e137ebb51f3bd39"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_message_request_observer_interface.html">avsCommon::sdkInterfaces::MessageRequestObserverInterface</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#ad67b78688c70a3a33e137ebb51f3bd39">m_observers</a></td></tr>
<tr class="memdesc:ad67b78688c70a3a33e137ebb51f3bd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of observers of MessageRequestObserverInterface.  <a href="#ad67b78688c70a3a33e137ebb51f3bd39">More...</a><br /></td></tr>
<tr class="separator:ad67b78688c70a3a33e137ebb51f3bd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f042e8bce1352f1359b111e5c5355b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#af7f042e8bce1352f1359b111e5c5355b">m_jsonContent</a></td></tr>
<tr class="memdesc:af7f042e8bce1352f1359b111e5c5355b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The JSON content to be sent to AVS.  <a href="#af7f042e8bce1352f1359b111e5c5355b">More...</a><br /></td></tr>
<tr class="separator:af7f042e8bce1352f1359b111e5c5355b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8990c10520935ee10478cac71132237"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#ab8990c10520935ee10478cac71132237">m_isSerialized</a></td></tr>
<tr class="memdesc:ab8990c10520935ee10478cac71132237"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if sending this message must be serialized with sending other serialized messages.  <a href="#ab8990c10520935ee10478cac71132237">More...</a><br /></td></tr>
<tr class="separator:ab8990c10520935ee10478cac71132237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cd79d5ac89983f17b6c1d90a8942bf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a23cd79d5ac89983f17b6c1d90a8942bf">m_uriPathExtension</a></td></tr>
<tr class="memdesc:a23cd79d5ac89983f17b6c1d90a8942bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The path extension to be appended to the base URL when sending.  <a href="#a23cd79d5ac89983f17b6c1d90a8942bf">More...</a><br /></td></tr>
<tr class="separator:a23cd79d5ac89983f17b6c1d90a8942bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057aa763160b1417dc31f93706fa5a8f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_named_reader.html">NamedReader</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a057aa763160b1417dc31f93706fa5a8f">m_readers</a></td></tr>
<tr class="memdesc:a057aa763160b1417dc31f93706fa5a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The AttachmentReaders of the Attachments data to be sent to AVS.  <a href="#a057aa763160b1417dc31f93706fa5a8f">More...</a><br /></td></tr>
<tr class="separator:a057aa763160b1417dc31f93706fa5a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaf0397a65cb0cec12668ad2129b778"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#acaaf0397a65cb0cec12668ad2129b778">m_headers</a></td></tr>
<tr class="memdesc:acaaf0397a65cb0cec12668ad2129b778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional headers to send with this request to AVS.  <a href="#acaaf0397a65cb0cec12668ad2129b778">More...</a><br /></td></tr>
<tr class="separator:acaaf0397a65cb0cec12668ad2129b778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00956a3f08d202b675a199c5babbac3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#aef0454cedb3c097a3c2701fee718ef38">MessageRequestResolveFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a00956a3f08d202b675a199c5babbac3a">m_resolver</a></td></tr>
<tr class="memdesc:a00956a3f08d202b675a199c5babbac3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolver function to resolve current message request to a valid state. Null if message is already resolved.  <a href="#a00956a3f08d202b675a199c5babbac3a">More...</a><br /></td></tr>
<tr class="separator:a00956a3f08d202b675a199c5babbac3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f401088d3a01b0a1f25ff6db28bc24"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#a77f401088d3a01b0a1f25ff6db28bc24">m_streamMetricName</a></td></tr>
<tr class="memdesc:a77f401088d3a01b0a1f25ff6db28bc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name for the stream byte metric.  <a href="#a77f401088d3a01b0a1f25ff6db28bc24">More...</a><br /></td></tr>
<tr class="separator:a77f401088d3a01b0a1f25ff6db28bc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae492e9449889da0a71fd45a2bca2d44b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#ae492e9449889da0a71fd45a2bca2d44b">m_streamBytesThreshold</a></td></tr>
<tr class="memdesc:ae492e9449889da0a71fd45a2bca2d44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threshold for the number of bytes for when we should record the stream metric.  <a href="#ae492e9449889da0a71fd45a2bca2d44b">More...</a><br /></td></tr>
<tr class="separator:ae492e9449889da0a71fd45a2bca2d44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a wrapper class which allows a client to send a Message to AVS, and be notified when the attempt to send the Message was completed. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aef0454cedb3c097a3c2701fee718ef38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0454cedb3c097a3c2701fee718ef38">&#9670;&nbsp;</a></span>MessageRequestResolveFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#aef0454cedb3c097a3c2701fee718ef38">alexaClientSDK::avsCommon::avs::MessageRequest::MessageRequestResolveFunction</a> =  std::function&lt;bool(const std::shared_ptr&lt;<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_editable_message_request.html">EditableMessageRequest</a>&gt;&amp; req, const std::string&amp; resolveKey)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to resolve an editable message request based on the provided resolveKey by updating the <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">req</td><td>Target editable request message that will be modified in place. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">resolveKey</td><td>Key used to resolve the message request </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if resolving successfully, else @ false </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function need to be thread-safe, and is allowed to block. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a269bdec60ec3c6b4b0cf4d81ca0468d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269bdec60ec3c6b4b0cf4d81ca0468d6">&#9670;&nbsp;</a></span>MessageRequest() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">alexaClientSDK::avsCommon::avs::MessageRequest::MessageRequest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>jsonContent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uriPathExtension</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>streamMetricName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonContent</td><td>The message to be sent to AVS. </td></tr>
    <tr><td class="paramname">uriPathExtension</td><td>An optional uri path extension which will be appended to the base url of the AVS. endpoint. If not specified, the default AVS path extension should be used by the sender implementation. </td></tr>
    <tr><td class="paramname">threshold.</td><td>An optional threshold to ACL to send the metric specified by streamMetricName. If this isn't specified no metric will be recorded. </td></tr>
    <tr><td class="paramname">streamMetricName.</td><td>An optional metric name for ACL to submit when the threshold is met. If this isn't specified no metric will be recorded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60bedccff5260f1d06281f775c4d0acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bedccff5260f1d06281f775c4d0acf">&#9670;&nbsp;</a></span>MessageRequest() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">alexaClientSDK::avsCommon::avs::MessageRequest::MessageRequest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>jsonContent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>streamMetricName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonContent</td><td>The message to be sent to AVS. </td></tr>
    <tr><td class="paramname">threshold.</td><td>A required threshold to ACL to send the metric specified by streamMetricName. </td></tr>
    <tr><td class="paramname">streamMetricName.</td><td>A required metric name for ACL to submit when the threshold is met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78858e1d0c2e637c97aecba08ccf4e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78858e1d0c2e637c97aecba08ccf4e23">&#9670;&nbsp;</a></span>MessageRequest() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">alexaClientSDK::avsCommon::avs::MessageRequest::MessageRequest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>jsonContent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSerialized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uriPathExtension</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt;&#160;</td>
          <td class="paramname"><em>headers</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#aef0454cedb3c097a3c2701fee718ef38">MessageRequestResolveFunction</a>&#160;</td>
          <td class="paramname"><em>resolver</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>streamMetricName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonContent</td><td>The message to be sent to AVS. </td></tr>
    <tr><td class="paramname">isSerialized</td><td>True if sending this message must be serialized with sending other serialized messages. </td></tr>
    <tr><td class="paramname">uriPathExtension</td><td>An optional uri path extension which will be appended to the base url of the AVS. </td></tr>
    <tr><td class="paramname">headers</td><td>key/value pairs of extra HTTP headers to use with this request. endpoint. If not specified, the default AVS path extension should be used by the sender implementation. </td></tr>
    <tr><td class="paramname">resolver</td><td>Function to resolve message. Null if message doesn't need resolving. Resolving function aims to support the use case that one message request will be sent to multiple places with some fields having different values for different destinations. In such use cases, <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a></code> works as a container with all required info to build different versions of requests. The resolving function contains the logic to build the target message request based on the info in the original request, and provided resolveKey. </td></tr>
    <tr><td class="paramname">threshold.</td><td>An optional threshold to ACL to send the metric specified by streamMetricName. If this isn't specified no metric will be recorded. </td></tr>
    <tr><td class="paramname">streamMetricName.</td><td>An optional metric name for ACL to submit when the threshold is met. If this isn't specified no metric will be recorded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab93eed92b60d6e2681db5f6500b99a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93eed92b60d6e2681db5f6500b99a89">&#9670;&nbsp;</a></span>MessageRequest() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">alexaClientSDK::avsCommon::avs::MessageRequest::MessageRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>messageRequest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor to construct a <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a> which contains a copy of the data in <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageRequest</td><td><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a> to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Observers are not considered data and don't get copied by this constructor. </dd></dl>

</div>
</div>
<a id="a11c8ce94cf135b8c0959174a1c33e3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c8ce94cf135b8c0959174a1c33e3e3">&#9670;&nbsp;</a></span>~MessageRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual alexaClientSDK::avsCommon::avs::MessageRequest::~MessageRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7f6ff7cc1d2b684a16ea33e706b5600e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6ff7cc1d2b684a16ea33e706b5600e">&#9670;&nbsp;</a></span>addAttachmentReader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::avsCommon::avs::MessageRequest::addAttachmentReader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">attachment::AttachmentReader</a> &gt;&#160;</td>
          <td class="paramname"><em>attachmentReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an attachment reader to the message. The attachment data will be the next part in the message to be sent to AVS. </p><dl class="section note"><dt>Note</dt><dd>: The order by which the message attachments sent to AVS is the one by which they have been added to it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the message part containing the attachment data. </td></tr>
    <tr><td class="paramname">attachmentReader</td><td>The attachment data to be sent to AVS along with the message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0a451c99ee5d47c639e89b668e7830f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a451c99ee5d47c639e89b668e7830f">&#9670;&nbsp;</a></span>addObserver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::avsCommon::avs::MessageRequest::addObserver </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_message_request_observer_interface.html">avsCommon::sdkInterfaces::MessageRequestObserverInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add observer of MessageRequestObserverInterface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>The observer to be added to the set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64339a63366cccdc2035b41717d4e2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64339a63366cccdc2035b41717d4e2fb">&#9670;&nbsp;</a></span>attachmentReadersCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int alexaClientSDK::avsCommon::avs::MessageRequest::attachmentReadersCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of <code>AttachmentReaders</code> in this message.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of readers in this message. </dd></dl>

</div>
</div>
<a id="aacd8629bc9d5369b0a9c7b041c441fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd8629bc9d5369b0a9c7b041c441fa2">&#9670;&nbsp;</a></span>exceptionReceived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void alexaClientSDK::avsCommon::avs::MessageRequest::exceptionReceived </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exceptionMessage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will be called if AVS responds with an exception message to this message request being sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exceptionMessage</td><td>The exception message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb9f5dd4f64acd9cb8986eb3b7095b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9f5dd4f64acd9cb8986eb3b7095b25">&#9670;&nbsp;</a></span>getAttachmentReader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_named_reader.html">NamedReader</a>&gt; alexaClientSDK::avsCommon::avs::MessageRequest::getAttachmentReader </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the ith AttachmentReader in the message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the <code>AttachmentReader</code> to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_named_reader.html" title="A struct to hold an AttachmentReader alongside its name. ">NamedReader</a></code> of the ith attachment in the message. A null pointer is returned when <code>index</code> is out of bound. </dd></dl>

</div>
</div>
<a id="a504d3ce1f7ed9361abb21ebf89cad915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504d3ce1f7ed9361abb21ebf89cad915">&#9670;&nbsp;</a></span>getHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;&amp; alexaClientSDK::avsCommon::avs::MessageRequest::getHeaders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get additional HTTP headers for this request</p>
<dl class="section return"><dt>Returns</dt><dd>key/value pairs of extra HTTP headers to use with this request. </dd></dl>

</div>
</div>
<a id="a576d7a73b22a7e21adca66f154c42780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576d7a73b22a7e21adca66f154c42780">&#9670;&nbsp;</a></span>getIsSerialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::avsCommon::avs::MessageRequest::getIsSerialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if sending this message must be serialized with sending other serialized messages.</p>
<dl class="section return"><dt>Returns</dt><dd>True if sending this message must be serialized with sending other serialized messages. </dd></dl>

</div>
</div>
<a id="a8bbdfec53d194ffb82690bd8fa87d4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbdfec53d194ffb82690bd8fa87d4e7">&#9670;&nbsp;</a></span>getJsonContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string alexaClientSDK::avsCommon::avs::MessageRequest::getJsonContent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the JSON content to be sent to AVS.</p>
<dl class="section return"><dt>Returns</dt><dd>The JSON content to be sent to AVS. </dd></dl>

</div>
</div>
<a id="a5b5e3ddd4980d432b6572ca93f20e37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5e3ddd4980d432b6572ca93f20e37b">&#9670;&nbsp;</a></span>getStreamBytesThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int alexaClientSDK::avsCommon::avs::MessageRequest::getStreamBytesThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the stream bytes threshold, to determine when we should record the stream metric. </p><dl class="section return"><dt>Returns</dt><dd>m_threshold </dd></dl>

</div>
</div>
<a id="afc2ba4b1b576aad958c06f6f0f19a5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2ba4b1b576aad958c06f6f0f19a5a4">&#9670;&nbsp;</a></span>getStreamMetricName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string alexaClientSDK::avsCommon::avs::MessageRequest::getStreamMetricName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name for the bytes stream metric. </p><dl class="section return"><dt>Returns</dt><dd>m_streamMetricName </dd></dl>

</div>
</div>
<a id="a1fa82056f56c5a6d8d39ce73743c519b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa82056f56c5a6d8d39ce73743c519b">&#9670;&nbsp;</a></span>getUriPathExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string alexaClientSDK::avsCommon::avs::MessageRequest::getUriPathExtension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the path extension to be appended to the base URL when sending.</p>
<dl class="section return"><dt>Returns</dt><dd>The path extension to be appended to the base URL when sending. </dd></dl>

</div>
</div>
<a id="a35a451de93434914abb29201c5c5d430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a451de93434914abb29201c5c5d430">&#9670;&nbsp;</a></span>isResolved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::avsCommon::avs::MessageRequest::isResolved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether message is resolved and ready to send. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if message is already resolved, else <code>false</code> </dd></dl>

</div>
</div>
<a id="a31fe3acc9b87911b14fb4a10d98d6dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fe3acc9b87911b14fb4a10d98d6dda">&#9670;&nbsp;</a></span>removeObserver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::avsCommon::avs::MessageRequest::removeObserver </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_message_request_observer_interface.html">avsCommon::sdkInterfaces::MessageRequestObserverInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove observer of MessageRequestObserverInterface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>The observer to be removed from the set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1289e5b067fb754b4729ce09b951e58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1289e5b067fb754b4729ce09b951e58c">&#9670;&nbsp;</a></span>resolveRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a>&gt; alexaClientSDK::avsCommon::avs::MessageRequest::resolveRequest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resolveKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resolve message to a valid message by updating the content of the message based on provided resolveKey </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolveKey</td><td>Key used to resolve message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New resolved <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a> </dd></dl>

</div>
</div>
<a id="aa35914042b8aee72a25243d241937556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35914042b8aee72a25243d241937556">&#9670;&nbsp;</a></span>responseStatusReceived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void alexaClientSDK::avsCommon::avs::MessageRequest::responseStatusReceived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_message_request_observer_interface.html#a29e40517f71dfc83e3159a8f0f489d7b">avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when the Response code is received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The status of the response that was received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac15b73d5036d673b5530d84f394d0eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15b73d5036d673b5530d84f394d0eb8">&#9670;&nbsp;</a></span>retrieveEventHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_event_headers.html">EventHeaders</a> alexaClientSDK::avsCommon::avs::MessageRequest::retrieveEventHeaders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html">MessageRequest</a> event headers (namespace and name).</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_event_headers.html" title="A struct to hold event namespace and name. ">EventHeaders</a> containing the namespace and name. </dd></dl>

</div>
</div>
<a id="ac71521a1ba3d1ace735798190c5059e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71521a1ba3d1ace735798190c5059e5">&#9670;&nbsp;</a></span>sendCompleted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void alexaClientSDK::avsCommon::avs::MessageRequest::sendCompleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_message_request_observer_interface.html#a29e40517f71dfc83e3159a8f0f489d7b">avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is called once the send request has completed. The status parameter indicates success or failure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Whether the send request succeeded or failed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classalexa_client_s_d_k_1_1capability_agents_1_1playback_controller_1_1_playback_message_request.html#a30ddec50a46dc7e06f08b0a0bb898611">alexaClientSDK::capabilityAgents::playbackController::PlaybackMessageRequest</a>, <a class="el" href="classalexa_client_s_d_k_1_1capability_agents_1_1do_not_disturb_1_1_d_n_d_message_request.html#abaec0b5f39f5264c5e5501325028e163">alexaClientSDK::capabilityAgents::doNotDisturb::DNDMessageRequest</a>, and <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_waitable_message_request.html#a86aafd839f920b40ca5cd57acb94a9ca">alexaClientSDK::avsCommon::avs::WaitableMessageRequest</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acaaf0397a65cb0cec12668ad2129b778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaaf0397a65cb0cec12668ad2129b778">&#9670;&nbsp;</a></span>m_headers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; alexaClientSDK::avsCommon::avs::MessageRequest::m_headers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional headers to send with this request to AVS. </p>

</div>
</div>
<a id="ab8990c10520935ee10478cac71132237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8990c10520935ee10478cac71132237">&#9670;&nbsp;</a></span>m_isSerialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::avsCommon::avs::MessageRequest::m_isSerialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if sending this message must be serialized with sending other serialized messages. </p>

</div>
</div>
<a id="af7f042e8bce1352f1359b111e5c5355b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f042e8bce1352f1359b111e5c5355b">&#9670;&nbsp;</a></span>m_jsonContent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string alexaClientSDK::avsCommon::avs::MessageRequest::m_jsonContent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The JSON content to be sent to AVS. </p>

</div>
</div>
<a id="a423d6a102e3d537ccb4b56d185a14bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423d6a102e3d537ccb4b56d185a14bf8">&#9670;&nbsp;</a></span>m_observerMutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex alexaClientSDK::avsCommon::avs::MessageRequest::m_observerMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex to guard access of m_observers. </p>

</div>
</div>
<a id="ad67b78688c70a3a33e137ebb51f3bd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67b78688c70a3a33e137ebb51f3bd39">&#9670;&nbsp;</a></span>m_observers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;std::shared_ptr&lt;<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_message_request_observer_interface.html">avsCommon::sdkInterfaces::MessageRequestObserverInterface</a>&gt; &gt; alexaClientSDK::avsCommon::avs::MessageRequest::m_observers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set of observers of MessageRequestObserverInterface. </p>

</div>
</div>
<a id="a057aa763160b1417dc31f93706fa5a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057aa763160b1417dc31f93706fa5a8f">&#9670;&nbsp;</a></span>m_readers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request_1_1_named_reader.html">NamedReader</a>&gt; &gt; alexaClientSDK::avsCommon::avs::MessageRequest::m_readers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The AttachmentReaders of the Attachments data to be sent to AVS. </p>

</div>
</div>
<a id="a00956a3f08d202b675a199c5babbac3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00956a3f08d202b675a199c5babbac3a">&#9670;&nbsp;</a></span>m_resolver</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1_message_request.html#aef0454cedb3c097a3c2701fee718ef38">MessageRequestResolveFunction</a> alexaClientSDK::avsCommon::avs::MessageRequest::m_resolver</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolver function to resolve current message request to a valid state. Null if message is already resolved. </p>

</div>
</div>
<a id="ae492e9449889da0a71fd45a2bca2d44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae492e9449889da0a71fd45a2bca2d44b">&#9670;&nbsp;</a></span>m_streamBytesThreshold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int alexaClientSDK::avsCommon::avs::MessageRequest::m_streamBytesThreshold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The threshold for the number of bytes for when we should record the stream metric. </p>

</div>
</div>
<a id="a77f401088d3a01b0a1f25ff6db28bc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f401088d3a01b0a1f25ff6db28bc24">&#9670;&nbsp;</a></span>m_streamMetricName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string alexaClientSDK::avsCommon::avs::MessageRequest::m_streamMetricName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name for the stream byte metric. </p>

</div>
</div>
<a id="a23cd79d5ac89983f17b6c1d90a8942bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cd79d5ac89983f17b6c1d90a8942bf">&#9670;&nbsp;</a></span>m_uriPathExtension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string alexaClientSDK::avsCommon::avs::MessageRequest::m_uriPathExtension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The path extension to be appended to the base URL when sending. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/workplace/avs-device-sdk/AVSCommon/AVS/include/AVSCommon/AVS/<a class="el" href="_message_request_8h_source.html">MessageRequest.h</a></li>
</ul>
</div><!-- contents -->
<html>
  <body>
    <p style="text-align:left;">
      AlexaClientSDK 3.0.0 - Copyright 2016-2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
      <span style="float:right;">
	Licensed under the <a HREF=http://aws.amazon.com/apache2.0/>Apache License, Version 2.0</a>
      </span>
    </p>
  </body>
</html>
