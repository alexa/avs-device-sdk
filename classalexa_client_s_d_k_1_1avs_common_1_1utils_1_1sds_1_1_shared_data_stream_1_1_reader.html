<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AlexaClientSDK: alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="avs-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AlexaClientSDK
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">A cross-platform, modular SDK for interacting with the Alexa Voice Service</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacealexa_client_s_d_k.html">alexaClientSDK</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common.html">avsCommon</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html">sds</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a></li><li class="navelem"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_reader_8h_source.html">Reader.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader_1_1_error.html">Error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6e323e30dec60992cd3219566ddcbfe0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a6e323e30dec60992cd3219566ddcbfe0">Policy</a> = <a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a07d2a9441f40d089a1f9a0d7e2baab4b">ReaderPolicy</a></td></tr>
<tr class="memdesc:a6e323e30dec60992cd3219566ddcbfe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the policy to use for reading from the stream.  <a href="#a6e323e30dec60992cd3219566ddcbfe0">More...</a><br /></td></tr>
<tr class="separator:a6e323e30dec60992cd3219566ddcbfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf4dfedfd9de2aeb6cd684afd5ed38c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a9bf4dfedfd9de2aeb6cd684afd5ed38c">OutputFunction</a> = std::function&lt; bool(void *buf, size_t nWords)&gt;</td></tr>
<tr class="separator:a9bf4dfedfd9de2aeb6cd684afd5ed38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad49959ffd5fdf1b3bfb70647f65a08d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#ad49959ffd5fdf1b3bfb70647f65a08d4">Reader</a> (<a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a07d2a9441f40d089a1f9a0d7e2baab4b">Policy</a> policy, std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a> &gt; bufferLayout, size_t id)</td></tr>
<tr class="separator:ad49959ffd5fdf1b3bfb70647f65a08d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a98bb7ebd77885e98c8cc93eba62f55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a8a98bb7ebd77885e98c8cc93eba62f55">~Reader</a> ()</td></tr>
<tr class="memdesc:a8a98bb7ebd77885e98c8cc93eba62f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This destructor detaches the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> from a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></code>.  <a href="#a8a98bb7ebd77885e98c8cc93eba62f55">More...</a><br /></td></tr>
<tr class="separator:a8a98bb7ebd77885e98c8cc93eba62f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af003c65c65026bbbbd27101f2094cb8c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#af003c65c65026bbbbd27101f2094cb8c">read</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a9bf4dfedfd9de2aeb6cd684afd5ed38c">OutputFunction</a> function, size_t maxWordsCanRead, std::chrono::milliseconds timeout=std::chrono::milliseconds(0))</td></tr>
<tr class="separator:af003c65c65026bbbbd27101f2094cb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a659ec04bf29971a87bf104ae4a37a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a33a659ec04bf29971a87bf104ae4a37a">read</a> (void *buf, size_t nWords, std::chrono::milliseconds timeout=std::chrono::milliseconds(0))</td></tr>
<tr class="separator:a33a659ec04bf29971a87bf104ae4a37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fff66cc486dd687247c6414540f978b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a4fff66cc486dd687247c6414540f978b">seek</a> (Index offset, <a class="el" href="_reader_8h.html#af8301ba5b9319ad0427cfe10efcf91ba">Reference</a> reference=Reference::ABSOLUTE)</td></tr>
<tr class="separator:a4fff66cc486dd687247c6414540f978b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40081e79c81c7cd87e9e35a20d323a93"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a40081e79c81c7cd87e9e35a20d323a93">tell</a> (<a class="el" href="_reader_8h.html#af8301ba5b9319ad0427cfe10efcf91ba">Reference</a> reference=Reference::ABSOLUTE) const</td></tr>
<tr class="separator:a40081e79c81c7cd87e9e35a20d323a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfaf0f8a72a0d7bd2be54fe1068708d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a0bfaf0f8a72a0d7bd2be54fe1068708d">close</a> (Index offset=0, <a class="el" href="_reader_8h.html#af8301ba5b9319ad0427cfe10efcf91ba">Reference</a> reference=Reference::AFTER_READER)</td></tr>
<tr class="separator:a0bfaf0f8a72a0d7bd2be54fe1068708d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b18bc13fa984f2eb42810595774c50"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a44b18bc13fa984f2eb42810595774c50">getId</a> () const</td></tr>
<tr class="separator:a44b18bc13fa984f2eb42810595774c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ca1bcf8d7da16493a7681b42af972e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a25ca1bcf8d7da16493a7681b42af972e">getWordSize</a> () const</td></tr>
<tr class="separator:a25ca1bcf8d7da16493a7681b42af972e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a07a4a0bd75c8464b0ed6e00437011b6d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a07a4a0bd75c8464b0ed6e00437011b6d">errorToString</a> (<a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader_1_1_error.html">Error</a> error)</td></tr>
<tr class="separator:a07a4a0bd75c8464b0ed6e00437011b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader&lt; T &gt;</h3>

<p>This is a nested class in <a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a> which provides an interface for reading (consuming) data from a stream.</p>
<dl class="section note"><dt>Note</dt><dd>This class is primarily intended to be used from a single thread. The <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> as a whole is thread-safe in the sense that <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_writer.html">Writer</a></code> and <code>Readers</code> can all live in different threads, but individual member functions of a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> instance should not be called from multiple threads except where specifically noted in function documentation below. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9bf4dfedfd9de2aeb6cd684afd5ed38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf4dfedfd9de2aeb6cd684afd5ed38c">&#9670;&nbsp;</a></span>OutputFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a9bf4dfedfd9de2aeb6cd684afd5ed38c">OutputFunction</a> =  std::function&lt;bool(void* buf, size_t nWords)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is passed in a read call to allow reading directly from the raw buffer. This allows you to avoid an intermediate copy while using a reader. It is passed into a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> below in with a read call and no reference to the lambda will be saved after the read function has returned. Implementations are not required to be thread safe, callbacks will return before the next one is called.</p>
<p>Since nWords is bound by nWords in the read function it is assumed that the caller will consume the entire buffer in every callback.</p>
<dl class="section note"><dt>Note</dt><dd>This function can be called multiple times per call to read depending on the implementation of <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a></code> and how much data was requested and it is up to the caller to handle multiple calls and the offsets into the caller's buffer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to read from. Note that this pointer is only valid for this read and there are no guarantees on it after the read is complete. </td></tr>
    <tr><td class="paramname">nWords</td><td>The number of <code>wordSize</code> words that are safe to read from buf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all words consumed, false otherwise. Returning false will cause the read function to fail and not consume any words from the <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a>. </dd></dl>

</div>
</div>
<a id="a6e323e30dec60992cd3219566ddcbfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e323e30dec60992cd3219566ddcbfe0">&#9670;&nbsp;</a></span>Policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::<a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a07d2a9441f40d089a1f9a0d7e2baab4b">Policy</a> =  <a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a07d2a9441f40d089a1f9a0d7e2baab4b">ReaderPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the policy to use for reading from the stream. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad49959ffd5fdf1b3bfb70647f65a08d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49959ffd5fdf1b3bfb70647f65a08d4">&#9670;&nbsp;</a></span>Reader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a07d2a9441f40d089a1f9a0d7e2baab4b">Policy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a> &gt;&#160;</td>
          <td class="paramname"><em>bufferLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> which consumes data from the provided <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a></code>. The caller must hold <code>Header::readerEnableMutex</code> when constructing new Readers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The policy to use for reading from the stream. </td></tr>
    <tr><td class="paramname">bufferLayout</td><td>The <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></code> to use for reading stream data. </td></tr>
    <tr><td class="paramname">id</td><td>The id of the reader, assigned by the <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a98bb7ebd77885e98c8cc93eba62f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a98bb7ebd77885e98c8cc93eba62f55">&#9670;&nbsp;</a></span>~Reader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::~<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This destructor detaches the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> from a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_buffer_layout.html">BufferLayout</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0bfaf0f8a72a0d7bd2be54fe1068708d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfaf0f8a72a0d7bd2be54fe1068708d">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::close </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_reader_8h.html#af8301ba5b9319ad0427cfe10efcf91ba">Reference</a>&#160;</td>
          <td class="paramname"><em>reference</em> = <code>Reference::AFTER_READER</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the point at which the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a>'s</code> stream will close. With the default parameters, this function will close the stream immediately, without reading any additional data. To schedule the stream to close once all the data which is currently in the buffer has been read, call <code>close(0, Reference::BEFORE_WRITER)</code>. If another close point is desired, it can be specified using a different <code>offset</code> and/or <code>reference</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The position (in <code>wordSize</code> words) in the stream, relative to <code>reference</code>, to close at. </td></tr>
    <tr><td class="paramname">reference</td><td>The position in the stream the close point is measured against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can be called from any thread or process, and it will schedule the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> to close, however it will <em>not</em> wake up a <code>BLOCKING</code> <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> which is already blocked waiting for data. In the case of a blocked <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#af003c65c65026bbbbd27101f2094cb8c">read()</a></code>, that <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#af003c65c65026bbbbd27101f2094cb8c">read()</a></code> will return when it wakes up - either due to a timeout, or due to a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_writer.html">Writer</a></code> adding data to the stream. </dd></dl>

</div>
</div>
<a id="a07a4a0bd75c8464b0ed6e00437011b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a4a0bd75c8464b0ed6e00437011b6d">&#9670;&nbsp;</a></span>errorToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::errorToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader_1_1_error.html">Error</a>&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the text of an error code.</p>
<dl class="section return"><dt>Returns</dt><dd>Text of the specified error. </dd></dl>

</div>
</div>
<a id="a44b18bc13fa984f2eb42810595774c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b18bc13fa984f2eb42810595774c50">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the id assigned to this <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code>. If a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> instance is not destroyed cleanly (e.g. a <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> from another process that crashes), its id can be passed to <code>SharedDataStream::reset()</code> to free up its resources.</p>
<dl class="section return"><dt>Returns</dt><dd>The id assigned to this <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code>. </dd></dl>

</div>
</div>
<a id="a25ca1bcf8d7da16493a7681b42af972e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ca1bcf8d7da16493a7681b42af972e">&#9670;&nbsp;</a></span>getWordSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::getWordSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the word size (in bytes). All <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a></code> operations that work with data or position in the stream are quantified in words.</p>
<dl class="section return"><dt>Returns</dt><dd>The size (in bytes) of words for this <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a>'s</code> <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream.html">SharedDataStream</a></code>. </dd></dl>

</div>
</div>
<a id="af003c65c65026bbbbd27101f2094cb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af003c65c65026bbbbd27101f2094cb8c">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a9bf4dfedfd9de2aeb6cd684afd5ed38c">OutputFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxWordsCanRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function consumes data from the stream and passes it into the read function to avoid intermediate copies of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The read function that will take a read pointer and the number of words that it's expected to handle. The read function's parameter nWords will be equal to or less than maxWordsCanRead. This may be called twice on account of the circular buffer however the sum of nWords in both calls will be less than <code>maxWordsCanRead</code>. </td></tr>
    <tr><td class="paramname">maxWordsCanRead</td><td>The maximum number of <code>wordSize</code> words to copy. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum time to wait (if <code>policy</code> is <code>BLOCKING</code>) for data. If this parameter is zero, there is no timeout and blocking reads will wait forever. If <code>policy</code> is <code>NONBLOCKING</code>, this parameter is ignored. In the case of a timeout <code>function</code> will not be called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of <code>wordSize</code> words copied if data was consumed, or zero if the stream has closed, or a negative <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader_1_1_error.html">Error</a></code> code if the stream is still open, but no data could be consumed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A stream is closed for the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> if <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a0bfaf0f8a72a0d7bd2be54fe1068708d">Reader::close()</a></code> has been called on it, or if <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_writer.html#a14d8dcf215e22b0634a6bdb4339242c0">Writer::close()</a></code> has been called and the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> has consumed all remaining data left in the stream when the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_writer.html">Writer</a></code> closed. In the special case of a new stream, where no <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_writer.html">Writer</a></code> has been created, the stream is not considered to be closed for the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code>; attempts to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#af003c65c65026bbbbd27101f2094cb8c">read()</a></code> will either block or return <code>WOULDBLOCK</code>, depending on the <code>Policy</code>. </dd></dl>

</div>
</div>
<a id="a33a659ec04bf29971a87bf104ae4a37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a659ec04bf29971a87bf104ae4a37a">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nWords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function consumes data from the stream and copies it to the provided buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A buffer to copy the consumed data to. This buffer must be large enough to hold <code>nWords</code> (<code>nWords * wordSize</code> bytes). </td></tr>
    <tr><td class="paramname">nWords</td><td>The maximum number of <code>wordSize</code> words to copy. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum time to wait (if <code>policy</code> is <code>BLOCKING</code>) for data. If this parameter is zero, there is no timeout and blocking reads will wait forever. If <code>policy</code> is <code>NONBLOCKING</code>, this parameter is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of <code>wordSize</code> words copied if data was consumed, or zero if the stream has closed, or a negative <code><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader_1_1_error.html">Error</a></code> code if the stream is still open, but no data could be consumed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A stream is closed for the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> if <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a0bfaf0f8a72a0d7bd2be54fe1068708d">Reader::close()</a></code> has been called on it, or if <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_writer.html#a14d8dcf215e22b0634a6bdb4339242c0">Writer::close()</a></code> has been called and the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> has consumed all remaining data left in the stream when the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_writer.html">Writer</a></code> closed. In the special case of a new stream, where no <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_writer.html">Writer</a></code> has been created, the stream is not considered to be closed for the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code>; attempts to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#af003c65c65026bbbbd27101f2094cb8c">read()</a></code> will either block or return <code>WOULDBLOCK</code>, depending on the <code>Policy</code>. </dd></dl>

</div>
</div>
<a id="a4fff66cc486dd687247c6414540f978b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fff66cc486dd687247c6414540f978b">&#9670;&nbsp;</a></span>seek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::seek </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_reader_8h.html#af8301ba5b9319ad0427cfe10efcf91ba">Reference</a>&#160;</td>
          <td class="paramname"><em>reference</em> = <code>Reference::ABSOLUTE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function moves the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> to the specified location in the stream. If successful, subsequent calls to <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#af003c65c65026bbbbd27101f2094cb8c">read()</a></code> will start from the new location. For this function to succeed, the specified location <em>must</em> point at data which has not been pushed out of the buffer; if the specified location points at old data which has already been overwritten, the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a4fff66cc486dd687247c6414540f978b">seek()</a></code> call will fail. If the specified location points at future data which does not yet exist in the buffer, the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a4fff66cc486dd687247c6414540f978b">seek()</a></code> call will succeed. If the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html#a4fff66cc486dd687247c6414540f978b">seek()</a></code> call fails, the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> position will remain unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The position (in <code>wordSize</code> words) in the stream, relative to <code>reference</code>, to move the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> to. </td></tr>
    <tr><td class="paramname">reference</td><td>The position in the stream <code>offset</code> is applied to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified position points at unconsumed data, else <code>false</code>. </dd></dl>

</div>
</div>
<a id="a40081e79c81c7cd87e9e35a20d323a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40081e79c81c7cd87e9e35a20d323a93">&#9670;&nbsp;</a></span>tell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SharedDataStream&lt; T &gt;::Index <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">alexaClientSDK::avsCommon::utils::sds::SharedDataStream::Reader</a>&lt; T &gt;::tell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_reader_8h.html#af8301ba5b9319ad0427cfe10efcf91ba">Reference</a>&#160;</td>
          <td class="paramname"><em>reference</em> = <code>Reference::ABSOLUTE</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reports the current position of the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a></code> in the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>The position in the stream the return value is measured against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds_1_1_shared_data_stream_1_1_reader.html">Reader</a>'s</code> position (in <code>wordSize</code> words) in the stream relative to <code>reference</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For <code>Reference::BEFORE_WRITER</code>, if the read cursor points at a location in the future (after the writer), then the reader is not before the writer, so this function will return 0. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/workplace/avs-device-sdk/AVSCommon/Utils/include/AVSCommon/Utils/SDS/<a class="el" href="_reader_8h_source.html">Reader.h</a></li>
</ul>
</div><!-- contents -->
<html>
  <body>
    <p style="text-align:left;">
      AlexaClientSDK 3.0.0 - Copyright 2016-2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
      <span style="float:right;">
	Licensed under the <a HREF=http://aws.amazon.com/apache2.0/>Apache License, Version 2.0</a>
      </span>
    </p>
  </body>
</html>
