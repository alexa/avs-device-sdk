<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AlexaClientSDK: alexaClientSDK::playlistParser Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="avs-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AlexaClientSDK
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">A cross-platform, modular SDK for interacting with the Alexa Voice Service</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacealexa_client_s_d_k.html">alexaClientSDK</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html">playlistParser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">alexaClientSDK::playlistParser Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacealexa_client_s_d_k_1_1playlist_parser_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_content_decrypter.html">ContentDecrypter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_f_f_mpeg_input_buffer.html">FFMpegInputBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_id3_tags_remover.html">Id3TagsRemover</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_iterative_playlist_parser.html">IterativePlaylistParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalexa_client_s_d_k_1_1playlist_parser_1_1_m3_u_content.html">M3UContent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to encapsulate information retrieved from an M3U playlist.  <a href="structalexa_client_s_d_k_1_1playlist_parser_1_1_m3_u_content.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalexa_client_s_d_k_1_1playlist_parser_1_1_play_item.html">PlayItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_playlist_parser.html">PlaylistParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_url_content_to_attachment_converter.html">UrlContentToAttachmentConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that handles the streaming of urls containing media into <code>Attachments</code>.  <a href="classalexa_client_s_d_k_1_1playlist_parser_1_1_url_content_to_attachment_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abb353a54a9bac083933edf0b95d28cbd"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#abb353a54a9bac083933edf0b95d28cbd">ByteVector</a></td></tr>
<tr class="memdesc:abb353a54a9bac083933edf0b95d28cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for bytes.  <a href="#abb353a54a9bac083933edf0b95d28cbd">More...</a><br /></td></tr>
<tr class="separator:abb353a54a9bac083933edf0b95d28cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a19913fa969ee9f68005636e86f137318"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a19913fa969ee9f68005636e86f137318">isPlaylistExtendedM3U</a> (const std::string &amp;playlistContent)</td></tr>
<tr class="separator:a19913fa969ee9f68005636e86f137318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5de84beb501cf1ef8298bfec449bf02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalexa_client_s_d_k_1_1playlist_parser_1_1_m3_u_content.html">M3UContent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#af5de84beb501cf1ef8298bfec449bf02">parseM3UContent</a> (const std::string &amp;playlistURL, const std::string &amp;content)</td></tr>
<tr class="separator:af5de84beb501cf1ef8298bfec449bf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708ff6a18f574043096831078162f80b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser_1_1_encryption_info.html">avsCommon::utils::playlistParser::EncryptionInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a708ff6a18f574043096831078162f80b">parseHLSEncryptionLine</a> (const std::string &amp;line, const std::string &amp;baseURL)</td></tr>
<tr class="separator:a708ff6a18f574043096831078162f80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdae9b4039e5610cf6b234da350f289"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#aacdae9b4039e5610cf6b234da350f289">parsePlaylistMediaSequence</a> (const std::string &amp;line)</td></tr>
<tr class="separator:aacdae9b4039e5610cf6b234da350f289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e9ca8d172f5fed990f4d2e2b7054df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser.html#aaf393ec6797d10541b558b52bb9c5514">avsCommon::utils::playlistParser::ByteRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a83e9ca8d172f5fed990f4d2e2b7054df">parseHLSByteRangeLine</a> (const std::string &amp;line)</td></tr>
<tr class="separator:a83e9ca8d172f5fed990f4d2e2b7054df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe15b7a8fa28da8832e7cdd27697845c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser_1_1_playlist_entry.html">avsCommon::utils::playlistParser::PlaylistEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#afe15b7a8fa28da8832e7cdd27697845c">parseHLSMapLine</a> (const std::string &amp;line, const std::string &amp;baseURL)</td></tr>
<tr class="separator:afe15b7a8fa28da8832e7cdd27697845c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e8dbc555ef939f77144e06dcd93fcc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a43e8dbc555ef939f77144e06dcd93fcc">parsePLSContent</a> (const std::string &amp;playlistURL, const std::string &amp;content)</td></tr>
<tr class="separator:a43e8dbc555ef939f77144e06dcd93fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b02d4b00e634128dbdfecbd75a511b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a4b02d4b00e634128dbdfecbd75a511b5">removeCarriageReturnFromLine</a> (std::string *line)</td></tr>
<tr class="separator:a4b02d4b00e634128dbdfecbd75a511b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bafa78539b5e5478a3b0d031862c9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a85bafa78539b5e5478a3b0d031862c9c">readFromContentFetcher</a> (std::unique_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_h_t_t_p_content_fetcher_interface.html">avsCommon::sdkInterfaces::HTTPContentFetcherInterface</a> &gt; contentFetcher, std::string *content, std::atomic&lt; bool &gt; *shouldShutDown, std::string *playlistURL)</td></tr>
<tr class="separator:a85bafa78539b5e5478a3b0d031862c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0dac0a6c1b5fa747c9b3ec96dde590"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a0e0dac0a6c1b5fa747c9b3ec96dde590">isURLAbsolute</a> (const std::string &amp;url)</td></tr>
<tr class="separator:a0e0dac0a6c1b5fa747c9b3ec96dde590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc34b2e5077021a1b42555bd2e0a850"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a3cc34b2e5077021a1b42555bd2e0a850">getAbsoluteURLFromRelativePathToURL</a> (std::string baseURL, std::string relativePath, std::string *absoluteURL)</td></tr>
<tr class="separator:a3cc34b2e5077021a1b42555bd2e0a850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aad800c3ed05782b88068723118edc7bd"><td class="memItemLeft" align="right" valign="top">static constexpr long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#aad800c3ed05782b88068723118edc7bd">INVALID_MEDIA_SEQUENCE</a> = -1</td></tr>
<tr class="memdesc:aad800c3ed05782b88068723118edc7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid media sequence number.  <a href="#aad800c3ed05782b88068723118edc7bd">More...</a><br /></td></tr>
<tr class="separator:aad800c3ed05782b88068723118edc7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abb353a54a9bac083933edf0b95d28cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb353a54a9bac083933edf0b95d28cbd">&#9670;&nbsp;</a></span>ByteVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;unsigned char&gt; <a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#abb353a54a9bac083933edf0b95d28cbd">alexaClientSDK::playlistParser::ByteVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for bytes. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3cc34b2e5077021a1b42555bd2e0a850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc34b2e5077021a1b42555bd2e0a850">&#9670;&nbsp;</a></span>getAbsoluteURLFromRelativePathToURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::playlistParser::getAbsoluteURLFromRelativePathToURL </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>baseURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>relativePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>absoluteURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an absolute url, given a base url and a relative path from that url. For example, if "www.awesomewebsite.com/music/test.m3u" was the base url and the relative path was "music.mp3", "www.awesomewebsite.com/music/music.mp3" would be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">baseURL</td><td>The base url to add the relative path to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relativePath</td><td>The relative path to add to the base url. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">absoluteURL</td><td>The absolute url generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> If everything was successful and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a19913fa969ee9f68005636e86f137318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19913fa969ee9f68005636e86f137318">&#9670;&nbsp;</a></span>isPlaylistExtendedM3U()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::playlistParser::isPlaylistExtendedM3U </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>playlistContent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the playlist type of an M3U playlist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">playlistContent</td><td>The M3U playlist in <code>std::string</code> format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the playlist is extended M3U or <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a0e0dac0a6c1b5fa747c9b3ec96dde590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0dac0a6c1b5fa747c9b3ec96dde590">&#9670;&nbsp;</a></span>isURLAbsolute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::playlistParser::isURLAbsolute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether the provided url is an absolute url as opposed to a relative url. This is done by simply checking to see if the string contains the substring "://".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The url to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the url is an absolute url and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a83e9ca8d172f5fed990f4d2e2b7054df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e9ca8d172f5fed990f4d2e2b7054df">&#9670;&nbsp;</a></span>parseHLSByteRangeLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser.html#aaf393ec6797d10541b558b52bb9c5514">avsCommon::utils::playlistParser::ByteRange</a> alexaClientSDK::playlistParser::parseHLSByteRangeLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses #EXT-X-BYTERANGE line of HLS playlist and returns <code>ByteRange</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>ByteRange</code> - {start, end}. </dd></dl>

</div>
</div>
<a id="a708ff6a18f574043096831078162f80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708ff6a18f574043096831078162f80b">&#9670;&nbsp;</a></span>parseHLSEncryptionLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser_1_1_encryption_info.html">avsCommon::utils::playlistParser::EncryptionInfo</a> alexaClientSDK::playlistParser::parseHLSEncryptionLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses #EXT-X-KEY line of HLS playlist and returns <code>EncryptionInfo</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line to parse. </td></tr>
    <tr><td class="paramname">baseURL</td><td>The URL of the playlist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>EncryptionInfo</code>. </dd></dl>

</div>
</div>
<a id="afe15b7a8fa28da8832e7cdd27697845c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe15b7a8fa28da8832e7cdd27697845c">&#9670;&nbsp;</a></span>parseHLSMapLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser_1_1_playlist_entry.html">avsCommon::utils::playlistParser::PlaylistEntry</a> alexaClientSDK::playlistParser::parseHLSMapLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses #EXT-X-MAP line of HLS playlist and returns <code>PlaylistEntry</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line to parse. </td></tr>
    <tr><td class="paramname">baseURL</td><td>The url of the playlist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>PlaylistEntry</code>. </dd></dl>

</div>
</div>
<a id="af5de84beb501cf1ef8298bfec449bf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5de84beb501cf1ef8298bfec449bf02">&#9670;&nbsp;</a></span>parseM3UContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalexa_client_s_d_k_1_1playlist_parser_1_1_m3_u_content.html">M3UContent</a> alexaClientSDK::playlistParser::parseM3UContent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>playlistURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an M3U playlist and returns the "children" URLs in the order they appeared in the playlist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">playlistURL</td><td>The URL of the M3U playlist that needs to be parsed. </td></tr>
    <tr><td class="paramname">content</td><td>Text content of the downloaded M3U playlist to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="structalexa_client_s_d_k_1_1playlist_parser_1_1_m3_u_content.html" title="A struct used to encapsulate information retrieved from an M3U playlist. ">M3UContent</a></code> which contains parsed list of variant URLs (for master playlist) OR list of @ Playlist (for media playlist). </dd></dl>

</div>
</div>
<a id="aacdae9b4039e5610cf6b234da350f289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdae9b4039e5610cf6b234da350f289">&#9670;&nbsp;</a></span>parsePlaylistMediaSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long alexaClientSDK::playlistParser::parsePlaylistMediaSequence </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper method that parses the media sequence field. This method assumes that the line passed begins with the media sequence tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line to be parsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The media sequence value or <code>INVALID_MEDIA_SEQUENCE</code> if any issue happened during parsing. </dd></dl>

</div>
</div>
<a id="a43e8dbc555ef939f77144e06dcd93fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e8dbc555ef939f77144e06dcd93fcc">&#9670;&nbsp;</a></span>parsePLSContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; alexaClientSDK::playlistParser::parsePLSContent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>playlistURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an PLS playlist and returns the "children" URLs in the order they appeared in the playlist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The content to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of URLs in the order they appeared in the playlist. </dd></dl>

</div>
</div>
<a id="a85bafa78539b5e5478a3b0d031862c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bafa78539b5e5478a3b0d031862c9c">&#9670;&nbsp;</a></span>readFromContentFetcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::playlistParser::readFromContentFetcher </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1sdk_interfaces_1_1_h_t_t_p_content_fetcher_interface.html">avsCommon::sdkInterfaces::HTTPContentFetcherInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>contentFetcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::atomic&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>shouldShutDown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>playlistURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves playlist content and stores it into a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">contentFetcher</td><td>Object used to retrieve url content. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">content</td><td>The playlist content. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shouldShutDown</td><td>A pointer to allow for the caller to cancel the content retrieval asynchronously </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">playlistURL</td><td>A pointer to the playlist url. This will be updated in case the last used URL to fetch the content is different. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if no error occured or <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used to retrieve content specifically from playlist URLs. Attempting to use this on a media URL could be blocking forever as the URL might point to a live stream. </dd></dl>

</div>
</div>
<a id="a4b02d4b00e634128dbdfecbd75a511b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b02d4b00e634128dbdfecbd75a511b5">&#9670;&nbsp;</a></span>removeCarriageReturnFromLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::playlistParser::removeCarriageReturnFromLine </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a carriage return from the end of a line. This is required to handle Windows style line breaks ('<br />
'). std::getline reads by default up to '<br />
' so at times, the '' may be included when readinglines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line to parse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aad800c3ed05782b88068723118edc7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad800c3ed05782b88068723118edc7bd">&#9670;&nbsp;</a></span>INVALID_MEDIA_SEQUENCE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr long alexaClientSDK::playlistParser::INVALID_MEDIA_SEQUENCE = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An invalid media sequence number. </p>

</div>
</div>
</div><!-- contents -->
<html>
  <body>
    <p style="text-align:left;">
      AlexaClientSDK 3.0.0 - Copyright 2016-2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
      <span style="float:right;">
	Licensed under the <a HREF=http://aws.amazon.com/apache2.0/>Apache License, Version 2.0</a>
      </span>
    </p>
  </body>
</html>
